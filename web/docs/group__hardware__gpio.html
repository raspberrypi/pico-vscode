<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: hardware_gpio</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v1.5.1
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__hardware__gpio.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hardware_gpio<div class="ingroups"><a class="el" href="group__hardware.html">Hardware APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga8fcdfeff45cc2030530bf00c6ae1e0a3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga8fcdfeff45cc2030530bf00c6ae1e0a3">gpio_irq_callback_t</a>) (uint gpio, uint32_t event_mask)</td></tr>
<tr class="separator:ga8fcdfeff45cc2030530bf00c6ae1e0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga2af81373f9f5764ac1a5bd6097477530"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a> { <br />
&#160;&#160;<b>GPIO_FUNC_XIP</b> = 0
, <b>GPIO_FUNC_SPI</b> = 1
, <b>GPIO_FUNC_UART</b> = 2
, <b>GPIO_FUNC_I2C</b> = 3
, <br />
&#160;&#160;<b>GPIO_FUNC_PWM</b> = 4
, <b>GPIO_FUNC_SIO</b> = 5
, <b>GPIO_FUNC_PIO0</b> = 6
, <b>GPIO_FUNC_PIO1</b> = 7
, <br />
&#160;&#160;<b>GPIO_FUNC_GPCK</b> = 8
, <b>GPIO_FUNC_USB</b> = 9
, <b>GPIO_FUNC_NULL</b> = 0x1f
<br />
 }</td></tr>
<tr class="memdesc:ga2af81373f9f5764ac1a5bd6097477530"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO function definitions for use with function select.  <a href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">More...</a><br /></td></tr>
<tr class="separator:ga2af81373f9f5764ac1a5bd6097477530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6347e27da3ab34f1ea65b5ae16ab724f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> { <b>GPIO_IRQ_LEVEL_LOW</b> = 0x1u
, <b>GPIO_IRQ_LEVEL_HIGH</b> = 0x2u
, <b>GPIO_IRQ_EDGE_FALL</b> = 0x4u
, <b>GPIO_IRQ_EDGE_RISE</b> = 0x8u
 }</td></tr>
<tr class="memdesc:ga6347e27da3ab34f1ea65b5ae16ab724f"><td class="mdescLeft">&#160;</td><td class="mdescRight">GPIO Interrupt level definitions (GPIO events)  <a href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">More...</a><br /></td></tr>
<tr class="separator:ga6347e27da3ab34f1ea65b5ae16ab724f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72c250c9393043ea5beb56092d26e229"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a> { <a class="el" href="group__hardware__gpio.html#gga72c250c9393043ea5beb56092d26e229a6173e20f5be765a136661c48f9766634">GPIO_SLEW_RATE_SLOW</a> = 0
, <a class="el" href="group__hardware__gpio.html#gga72c250c9393043ea5beb56092d26e229a44b116ac7ac70a405c952a6054a1eade">GPIO_SLEW_RATE_FAST</a> = 1
 }</td></tr>
<tr class="memdesc:ga72c250c9393043ea5beb56092d26e229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Slew rate limiting levels for GPIO outputs.  <a href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">More...</a><br /></td></tr>
<tr class="separator:ga72c250c9393043ea5beb56092d26e229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14eba84c1c8f80b08a770775d3bf060a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a> { <a class="el" href="group__hardware__gpio.html#gga14eba84c1c8f80b08a770775d3bf060aa04d31285e4f4921102485e775e55e295">GPIO_DRIVE_STRENGTH_2MA</a> = 0
, <a class="el" href="group__hardware__gpio.html#gga14eba84c1c8f80b08a770775d3bf060aa5c9d0b430fd44ee7688d58cf94f47de6">GPIO_DRIVE_STRENGTH_4MA</a> = 1
, <a class="el" href="group__hardware__gpio.html#gga14eba84c1c8f80b08a770775d3bf060aa3cc28353572b5f8e8bb2eb80f884a98d">GPIO_DRIVE_STRENGTH_8MA</a> = 2
, <a class="el" href="group__hardware__gpio.html#gga14eba84c1c8f80b08a770775d3bf060aa418f6be7649c316bab248b91c2eb1716">GPIO_DRIVE_STRENGTH_12MA</a> = 3
 }</td></tr>
<tr class="memdesc:ga14eba84c1c8f80b08a770775d3bf060a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive strength levels for GPIO outputs.  <a href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">More...</a><br /></td></tr>
<tr class="separator:ga14eba84c1c8f80b08a770775d3bf060a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaacde9174277ca40aa7b6fdd341bb2b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">gpio_set_function</a> (uint gpio, enum <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a> fn)</td></tr>
<tr class="memdesc:gaacde9174277ca40aa7b6fdd341bb2b8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select GPIO function.  <a href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">More...</a><br /></td></tr>
<tr class="separator:gaacde9174277ca40aa7b6fdd341bb2b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac41d97649605d14d3e176e72d432c01a"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gac41d97649605d14d3e176e72d432c01a">gpio_get_function</a> (uint gpio)</td></tr>
<tr class="memdesc:gac41d97649605d14d3e176e72d432c01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current GPIO function.  <a href="group__hardware__gpio.html#gac41d97649605d14d3e176e72d432c01a">More...</a><br /></td></tr>
<tr class="separator:gac41d97649605d14d3e176e72d432c01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bf9552da32b3dd0a5d0db45d8374fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gab6bf9552da32b3dd0a5d0db45d8374fc">gpio_set_pulls</a> (uint gpio, bool up, bool down)</td></tr>
<tr class="memdesc:gab6bf9552da32b3dd0a5d0db45d8374fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select up and down pulls on specific GPIO.  <a href="group__hardware__gpio.html#gab6bf9552da32b3dd0a5d0db45d8374fc">More...</a><br /></td></tr>
<tr class="separator:gab6bf9552da32b3dd0a5d0db45d8374fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30a6733240f3d2e25e6b579b6c3902da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga30a6733240f3d2e25e6b579b6c3902da">gpio_pull_up</a> (uint gpio)</td></tr>
<tr class="memdesc:ga30a6733240f3d2e25e6b579b6c3902da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specified GPIO to be pulled up.  <a href="group__hardware__gpio.html#ga30a6733240f3d2e25e6b579b6c3902da">More...</a><br /></td></tr>
<tr class="separator:ga30a6733240f3d2e25e6b579b6c3902da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7038968884d02b67403a50f1be6ecd6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gac7038968884d02b67403a50f1be6ecd6">gpio_is_pulled_up</a> (uint gpio)</td></tr>
<tr class="memdesc:gac7038968884d02b67403a50f1be6ecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified GPIO is pulled up.  <a href="group__hardware__gpio.html#gac7038968884d02b67403a50f1be6ecd6">More...</a><br /></td></tr>
<tr class="separator:gac7038968884d02b67403a50f1be6ecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea499c33479cf8f87a91a74411ad241f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaea499c33479cf8f87a91a74411ad241f">gpio_pull_down</a> (uint gpio)</td></tr>
<tr class="memdesc:gaea499c33479cf8f87a91a74411ad241f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set specified GPIO to be pulled down.  <a href="group__hardware__gpio.html#gaea499c33479cf8f87a91a74411ad241f">More...</a><br /></td></tr>
<tr class="separator:gaea499c33479cf8f87a91a74411ad241f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54c35d7beb7025aa001ae5b93d38935b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga54c35d7beb7025aa001ae5b93d38935b">gpio_is_pulled_down</a> (uint gpio)</td></tr>
<tr class="memdesc:ga54c35d7beb7025aa001ae5b93d38935b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the specified GPIO is pulled down.  <a href="group__hardware__gpio.html#ga54c35d7beb7025aa001ae5b93d38935b">More...</a><br /></td></tr>
<tr class="separator:ga54c35d7beb7025aa001ae5b93d38935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae57a625b7e0bcac6d596f35864ffc792"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gae57a625b7e0bcac6d596f35864ffc792">gpio_disable_pulls</a> (uint gpio)</td></tr>
<tr class="memdesc:gae57a625b7e0bcac6d596f35864ffc792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable pulls on specified GPIO.  <a href="group__hardware__gpio.html#gae57a625b7e0bcac6d596f35864ffc792">More...</a><br /></td></tr>
<tr class="separator:gae57a625b7e0bcac6d596f35864ffc792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9788ec1b8306c6bacfb578f0074eb3ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga9788ec1b8306c6bacfb578f0074eb3ad">gpio_set_irqover</a> (uint gpio, uint value)</td></tr>
<tr class="memdesc:ga9788ec1b8306c6bacfb578f0074eb3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GPIO IRQ override.  <a href="group__hardware__gpio.html#ga9788ec1b8306c6bacfb578f0074eb3ad">More...</a><br /></td></tr>
<tr class="separator:ga9788ec1b8306c6bacfb578f0074eb3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga829129eed5d42f3455e9da339219d814"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga829129eed5d42f3455e9da339219d814">gpio_set_outover</a> (uint gpio, uint value)</td></tr>
<tr class="memdesc:ga829129eed5d42f3455e9da339219d814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set GPIO output override.  <a href="group__hardware__gpio.html#ga829129eed5d42f3455e9da339219d814">More...</a><br /></td></tr>
<tr class="separator:ga829129eed5d42f3455e9da339219d814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6037bdaf406a84336043c9a6c40e5073"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga6037bdaf406a84336043c9a6c40e5073">gpio_set_inover</a> (uint gpio, uint value)</td></tr>
<tr class="memdesc:ga6037bdaf406a84336043c9a6c40e5073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select GPIO input override.  <a href="group__hardware__gpio.html#ga6037bdaf406a84336043c9a6c40e5073">More...</a><br /></td></tr>
<tr class="separator:ga6037bdaf406a84336043c9a6c40e5073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga250e767769daabb71b5ea8cab49b4463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga250e767769daabb71b5ea8cab49b4463">gpio_set_oeover</a> (uint gpio, uint value)</td></tr>
<tr class="memdesc:ga250e767769daabb71b5ea8cab49b4463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select GPIO output enable override.  <a href="group__hardware__gpio.html#ga250e767769daabb71b5ea8cab49b4463">More...</a><br /></td></tr>
<tr class="separator:ga250e767769daabb71b5ea8cab49b4463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a8c3e55185581bc3df335aea1d0fb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga74a8c3e55185581bc3df335aea1d0fb8">gpio_set_input_enabled</a> (uint gpio, bool enabled)</td></tr>
<tr class="memdesc:ga74a8c3e55185581bc3df335aea1d0fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable GPIO input.  <a href="group__hardware__gpio.html#ga74a8c3e55185581bc3df335aea1d0fb8">More...</a><br /></td></tr>
<tr class="separator:ga74a8c3e55185581bc3df335aea1d0fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f52eecc12d4348ef8bd1e17bdb4b107"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga1f52eecc12d4348ef8bd1e17bdb4b107">gpio_set_input_hysteresis_enabled</a> (uint gpio, bool enabled)</td></tr>
<tr class="memdesc:ga1f52eecc12d4348ef8bd1e17bdb4b107"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable GPIO input hysteresis (Schmitt trigger)  <a href="group__hardware__gpio.html#ga1f52eecc12d4348ef8bd1e17bdb4b107">More...</a><br /></td></tr>
<tr class="separator:ga1f52eecc12d4348ef8bd1e17bdb4b107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac451f3251c0d0bea97aa535f65974ec8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gac451f3251c0d0bea97aa535f65974ec8">gpio_is_input_hysteresis_enabled</a> (uint gpio)</td></tr>
<tr class="memdesc:gac451f3251c0d0bea97aa535f65974ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether input hysteresis is enabled on a specified GPIO.  <a href="group__hardware__gpio.html#gac451f3251c0d0bea97aa535f65974ec8">More...</a><br /></td></tr>
<tr class="separator:gac451f3251c0d0bea97aa535f65974ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1d12efbed0809650d98fe9a424876c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaf1d12efbed0809650d98fe9a424876c8">gpio_set_slew_rate</a> (uint gpio, enum <a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a> slew)</td></tr>
<tr class="memdesc:gaf1d12efbed0809650d98fe9a424876c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set slew rate for a specified GPIO.  <a href="group__hardware__gpio.html#gaf1d12efbed0809650d98fe9a424876c8">More...</a><br /></td></tr>
<tr class="separator:gaf1d12efbed0809650d98fe9a424876c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4422d9c09199d199e8fe736b3c29ae49"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga4422d9c09199d199e8fe736b3c29ae49">gpio_get_slew_rate</a> (uint gpio)</td></tr>
<tr class="memdesc:ga4422d9c09199d199e8fe736b3c29ae49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current slew rate for a specified GPIO.  <a href="group__hardware__gpio.html#ga4422d9c09199d199e8fe736b3c29ae49">More...</a><br /></td></tr>
<tr class="separator:ga4422d9c09199d199e8fe736b3c29ae49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ffe0ddabcd081b513731275df97e7ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga0ffe0ddabcd081b513731275df97e7ca">gpio_set_drive_strength</a> (uint gpio, enum <a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a> drive)</td></tr>
<tr class="memdesc:ga0ffe0ddabcd081b513731275df97e7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set drive strength for a specified GPIO.  <a href="group__hardware__gpio.html#ga0ffe0ddabcd081b513731275df97e7ca">More...</a><br /></td></tr>
<tr class="separator:ga0ffe0ddabcd081b513731275df97e7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1378540c24ec318ac7674dac4ec30140"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga1378540c24ec318ac7674dac4ec30140">gpio_get_drive_strength</a> (uint gpio)</td></tr>
<tr class="memdesc:ga1378540c24ec318ac7674dac4ec30140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine current slew rate for a specified GPIO.  <a href="group__hardware__gpio.html#ga1378540c24ec318ac7674dac4ec30140">More...</a><br /></td></tr>
<tr class="separator:ga1378540c24ec318ac7674dac4ec30140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b1f920beba446c4d4385de999cf945"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">gpio_set_irq_enabled</a> (uint gpio, uint32_t event_mask, bool enabled)</td></tr>
<tr class="memdesc:ga08b1f920beba446c4d4385de999cf945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable specific interrupt events for specified GPIO.  <a href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">More...</a><br /></td></tr>
<tr class="separator:ga08b1f920beba446c4d4385de999cf945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b23dea291af5926735b5e8c87b7dbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a> (<a class="el" href="group__hardware__gpio.html#ga8fcdfeff45cc2030530bf00c6ae1e0a3">gpio_irq_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga37b23dea291af5926735b5e8c87b7dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the generic callback used for GPIO IRQ events for the current core.  <a href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">More...</a><br /></td></tr>
<tr class="separator:ga37b23dea291af5926735b5e8c87b7dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6165f07f4b619dd08ea6dc97d069e78a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga6165f07f4b619dd08ea6dc97d069e78a">gpio_set_irq_enabled_with_callback</a> (uint gpio, uint32_t event_mask, bool enabled, <a class="el" href="group__hardware__gpio.html#ga8fcdfeff45cc2030530bf00c6ae1e0a3">gpio_irq_callback_t</a> callback)</td></tr>
<tr class="memdesc:ga6165f07f4b619dd08ea6dc97d069e78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function which performs multiple GPIO IRQ related initializations.  <a href="group__hardware__gpio.html#ga6165f07f4b619dd08ea6dc97d069e78a">More...</a><br /></td></tr>
<tr class="separator:ga6165f07f4b619dd08ea6dc97d069e78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b10ec79e10d7df958373b178debcd2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga0b10ec79e10d7df958373b178debcd2e">gpio_set_dormant_irq_enabled</a> (uint gpio, uint32_t event_mask, bool enabled)</td></tr>
<tr class="memdesc:ga0b10ec79e10d7df958373b178debcd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable dormant wake up interrupt for specified GPIO and events.  <a href="group__hardware__gpio.html#ga0b10ec79e10d7df958373b178debcd2e">More...</a><br /></td></tr>
<tr class="separator:ga0b10ec79e10d7df958373b178debcd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2d1208ba7e3b02b23e7385350182583"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a> (uint gpio)</td></tr>
<tr class="memdesc:gaf2d1208ba7e3b02b23e7385350182583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current interrupt status (pending events) for the given GPIO.  <a href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">More...</a><br /></td></tr>
<tr class="separator:gaf2d1208ba7e3b02b23e7385350182583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga091c148a5cfaf2b55e716b6effef6360"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a> (uint gpio, uint32_t event_mask)</td></tr>
<tr class="memdesc:ga091c148a5cfaf2b55e716b6effef6360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acknowledge a GPIO interrupt for the specified events on the calling core.  <a href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">More...</a><br /></td></tr>
<tr class="separator:ga091c148a5cfaf2b55e716b6effef6360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga213978aec060f04ce3a674849c999b45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga213978aec060f04ce3a674849c999b45">gpio_add_raw_irq_handler_with_order_priority_masked</a> (uint gpio_mask, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler, uint8_t order_priority)</td></tr>
<tr class="memdesc:ga213978aec060f04ce3a674849c999b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a raw GPIO IRQ handler for the specified GPIOs on the current core.  <a href="group__hardware__gpio.html#ga213978aec060f04ce3a674849c999b45">More...</a><br /></td></tr>
<tr class="separator:ga213978aec060f04ce3a674849c999b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07c4de2660686b9158a5b0526ccbb446"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga07c4de2660686b9158a5b0526ccbb446">gpio_add_raw_irq_handler_with_order_priority</a> (uint gpio, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler, uint8_t order_priority)</td></tr>
<tr class="memdesc:ga07c4de2660686b9158a5b0526ccbb446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a raw GPIO IRQ handler for a specific GPIO on the current core.  <a href="group__hardware__gpio.html#ga07c4de2660686b9158a5b0526ccbb446">More...</a><br /></td></tr>
<tr class="separator:ga07c4de2660686b9158a5b0526ccbb446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37ab6047475687869bd84d90e183e09f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga37ab6047475687869bd84d90e183e09f">gpio_add_raw_irq_handler_masked</a> (uint gpio_mask, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga37ab6047475687869bd84d90e183e09f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a raw GPIO IRQ handler for the specified GPIOs on the current core.  <a href="group__hardware__gpio.html#ga37ab6047475687869bd84d90e183e09f">More...</a><br /></td></tr>
<tr class="separator:ga37ab6047475687869bd84d90e183e09f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e78fcd487a3a2e173322c6502fe9419"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga2e78fcd487a3a2e173322c6502fe9419">gpio_add_raw_irq_handler</a> (uint gpio, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga2e78fcd487a3a2e173322c6502fe9419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a raw GPIO IRQ handler for a specific GPIO on the current core.  <a href="group__hardware__gpio.html#ga2e78fcd487a3a2e173322c6502fe9419">More...</a><br /></td></tr>
<tr class="separator:ga2e78fcd487a3a2e173322c6502fe9419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb77622d0cd387bea253f10d8165c45e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gafb77622d0cd387bea253f10d8165c45e">gpio_remove_raw_irq_handler_masked</a> (uint gpio_mask, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:gafb77622d0cd387bea253f10d8165c45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a raw GPIO IRQ handler for the specified GPIOs on the current core.  <a href="group__hardware__gpio.html#gafb77622d0cd387bea253f10d8165c45e">More...</a><br /></td></tr>
<tr class="separator:gafb77622d0cd387bea253f10d8165c45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga495c253b01a68b0f81721d2061741243"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga495c253b01a68b0f81721d2061741243">gpio_remove_raw_irq_handler</a> (uint gpio, <a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a> handler)</td></tr>
<tr class="memdesc:ga495c253b01a68b0f81721d2061741243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a raw GPIO IRQ handler for the specified GPIO on the current core.  <a href="group__hardware__gpio.html#ga495c253b01a68b0f81721d2061741243">More...</a><br /></td></tr>
<tr class="separator:ga495c253b01a68b0f81721d2061741243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa4741d93dc40bc728dbd3e41813ad1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga8aa4741d93dc40bc728dbd3e41813ad1">gpio_init</a> (uint gpio)</td></tr>
<tr class="memdesc:ga8aa4741d93dc40bc728dbd3e41813ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a GPIO for (enabled I/O and set func to GPIO_FUNC_SIO)  <a href="group__hardware__gpio.html#ga8aa4741d93dc40bc728dbd3e41813ad1">More...</a><br /></td></tr>
<tr class="separator:ga8aa4741d93dc40bc728dbd3e41813ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df18d737955c17a65c5a94412826674"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga4df18d737955c17a65c5a94412826674">gpio_deinit</a> (uint gpio)</td></tr>
<tr class="memdesc:ga4df18d737955c17a65c5a94412826674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets a GPIO back to the NULL function, i.e. disables it.  <a href="group__hardware__gpio.html#ga4df18d737955c17a65c5a94412826674">More...</a><br /></td></tr>
<tr class="separator:ga4df18d737955c17a65c5a94412826674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3ccb15297fecd3792359d9cbbf6ed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga2f3ccb15297fecd3792359d9cbbf6ed6">gpio_init_mask</a> (uint gpio_mask)</td></tr>
<tr class="memdesc:ga2f3ccb15297fecd3792359d9cbbf6ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise multiple GPIOs (enabled I/O and set func to GPIO_FUNC_SIO)  <a href="group__hardware__gpio.html#ga2f3ccb15297fecd3792359d9cbbf6ed6">More...</a><br /></td></tr>
<tr class="separator:ga2f3ccb15297fecd3792359d9cbbf6ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38c0b39fba06d1a49d1be56ef548d73"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaf38c0b39fba06d1a49d1be56ef548d73">gpio_get</a> (uint gpio)</td></tr>
<tr class="memdesc:gaf38c0b39fba06d1a49d1be56ef548d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get state of a single specified GPIO.  <a href="group__hardware__gpio.html#gaf38c0b39fba06d1a49d1be56ef548d73">More...</a><br /></td></tr>
<tr class="separator:gaf38c0b39fba06d1a49d1be56ef548d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae895be2d3c5af5df460150eafe7858a4"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gae895be2d3c5af5df460150eafe7858a4">gpio_get_all</a> (void)</td></tr>
<tr class="memdesc:gae895be2d3c5af5df460150eafe7858a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get raw value of all GPIOs.  <a href="group__hardware__gpio.html#gae895be2d3c5af5df460150eafe7858a4">More...</a><br /></td></tr>
<tr class="separator:gae895be2d3c5af5df460150eafe7858a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3aa12aa4543965e24f52cfa9b529904"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaf3aa12aa4543965e24f52cfa9b529904">gpio_set_mask</a> (uint32_t mask)</td></tr>
<tr class="memdesc:gaf3aa12aa4543965e24f52cfa9b529904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive high every GPIO appearing in mask.  <a href="group__hardware__gpio.html#gaf3aa12aa4543965e24f52cfa9b529904">More...</a><br /></td></tr>
<tr class="separator:gaf3aa12aa4543965e24f52cfa9b529904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6aca495d644a6ae66050a99ef44defbe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga6aca495d644a6ae66050a99ef44defbe">gpio_clr_mask</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga6aca495d644a6ae66050a99ef44defbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive low every GPIO appearing in mask.  <a href="group__hardware__gpio.html#ga6aca495d644a6ae66050a99ef44defbe">More...</a><br /></td></tr>
<tr class="separator:ga6aca495d644a6ae66050a99ef44defbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64de3fa94def1d5e8c87f419f25ea7fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga64de3fa94def1d5e8c87f419f25ea7fd">gpio_xor_mask</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga64de3fa94def1d5e8c87f419f25ea7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle every GPIO appearing in mask.  <a href="group__hardware__gpio.html#ga64de3fa94def1d5e8c87f419f25ea7fd">More...</a><br /></td></tr>
<tr class="separator:ga64de3fa94def1d5e8c87f419f25ea7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac86436d117c7a87f982c9b3311543302"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gac86436d117c7a87f982c9b3311543302">gpio_put_masked</a> (uint32_t mask, uint32_t value)</td></tr>
<tr class="memdesc:gac86436d117c7a87f982c9b3311543302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive GPIO high/low depending on parameters.  <a href="group__hardware__gpio.html#gac86436d117c7a87f982c9b3311543302">More...</a><br /></td></tr>
<tr class="separator:gac86436d117c7a87f982c9b3311543302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aa41e10d04a8d99d9a8c4d7ba5007b8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga7aa41e10d04a8d99d9a8c4d7ba5007b8">gpio_put_all</a> (uint32_t value)</td></tr>
<tr class="memdesc:ga7aa41e10d04a8d99d9a8c4d7ba5007b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive all pins simultaneously.  <a href="group__hardware__gpio.html#ga7aa41e10d04a8d99d9a8c4d7ba5007b8">More...</a><br /></td></tr>
<tr class="separator:ga7aa41e10d04a8d99d9a8c4d7ba5007b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71d35b29e897b9bb4fc881b587b08cab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga71d35b29e897b9bb4fc881b587b08cab">gpio_put</a> (uint gpio, bool value)</td></tr>
<tr class="memdesc:ga71d35b29e897b9bb4fc881b587b08cab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drive a single GPIO high/low.  <a href="group__hardware__gpio.html#ga71d35b29e897b9bb4fc881b587b08cab">More...</a><br /></td></tr>
<tr class="separator:ga71d35b29e897b9bb4fc881b587b08cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a818ceaa50e3e2317fbb0856d47eaef"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga0a818ceaa50e3e2317fbb0856d47eaef">gpio_get_out_level</a> (uint gpio)</td></tr>
<tr class="memdesc:ga0a818ceaa50e3e2317fbb0856d47eaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether a GPIO is currently driven high or low.  <a href="group__hardware__gpio.html#ga0a818ceaa50e3e2317fbb0856d47eaef">More...</a><br /></td></tr>
<tr class="separator:ga0a818ceaa50e3e2317fbb0856d47eaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b2cc867ac41996100e881a768c7f969"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga7b2cc867ac41996100e881a768c7f969">gpio_set_dir_out_masked</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga7b2cc867ac41996100e881a768c7f969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a number of GPIOs to output.  <a href="group__hardware__gpio.html#ga7b2cc867ac41996100e881a768c7f969">More...</a><br /></td></tr>
<tr class="separator:ga7b2cc867ac41996100e881a768c7f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79819a97822983d7422d37c3e532cc53"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga79819a97822983d7422d37c3e532cc53">gpio_set_dir_in_masked</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga79819a97822983d7422d37c3e532cc53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a number of GPIOs to input.  <a href="group__hardware__gpio.html#ga79819a97822983d7422d37c3e532cc53">More...</a><br /></td></tr>
<tr class="separator:ga79819a97822983d7422d37c3e532cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa64fdceff54dda03f4427f04c2f9ced2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaa64fdceff54dda03f4427f04c2f9ced2">gpio_set_dir_masked</a> (uint32_t mask, uint32_t value)</td></tr>
<tr class="memdesc:gaa64fdceff54dda03f4427f04c2f9ced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set multiple GPIO directions.  <a href="group__hardware__gpio.html#gaa64fdceff54dda03f4427f04c2f9ced2">More...</a><br /></td></tr>
<tr class="separator:gaa64fdceff54dda03f4427f04c2f9ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50b526aa81f036a20c60f04106910578"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga50b526aa81f036a20c60f04106910578">gpio_set_dir_all_bits</a> (uint32_t values)</td></tr>
<tr class="memdesc:ga50b526aa81f036a20c60f04106910578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set direction of all pins simultaneously.  <a href="group__hardware__gpio.html#ga50b526aa81f036a20c60f04106910578">More...</a><br /></td></tr>
<tr class="separator:ga50b526aa81f036a20c60f04106910578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a40edf0d86f6b3f0dcb51a768cf4681"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga6a40edf0d86f6b3f0dcb51a768cf4681">gpio_set_dir</a> (uint gpio, bool out)</td></tr>
<tr class="memdesc:ga6a40edf0d86f6b3f0dcb51a768cf4681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single GPIO direction.  <a href="group__hardware__gpio.html#ga6a40edf0d86f6b3f0dcb51a768cf4681">More...</a><br /></td></tr>
<tr class="separator:ga6a40edf0d86f6b3f0dcb51a768cf4681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0dbc5c65103d483217a190b72ed26dc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#gaa0dbc5c65103d483217a190b72ed26dc">gpio_is_dir_out</a> (uint gpio)</td></tr>
<tr class="memdesc:gaa0dbc5c65103d483217a190b72ed26dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a specific GPIO direction is OUT.  <a href="group__hardware__gpio.html#gaa0dbc5c65103d483217a190b72ed26dc">More...</a><br /></td></tr>
<tr class="separator:gaa0dbc5c65103d483217a190b72ed26dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a78dd5d9b2a181794c632aa4881c5ed"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__gpio.html#ga2a78dd5d9b2a181794c632aa4881c5ed">gpio_get_dir</a> (uint gpio)</td></tr>
<tr class="memdesc:ga2a78dd5d9b2a181794c632aa4881c5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a specific GPIO direction.  <a href="group__hardware__gpio.html#ga2a78dd5d9b2a181794c632aa4881c5ed">More...</a><br /></td></tr>
<tr class="separator:ga2a78dd5d9b2a181794c632aa4881c5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >General Purpose Input/Output (GPIO) API</p>
<p >RP2040 has 36 multi-functional General Purpose Input / Output (GPIO) pins, divided into two banks. In a typical use case, the pins in the QSPI bank (QSPI_SS, QSPI_SCLK and QSPI_SD0 to QSPI_SD3) are used to execute code from an external flash device, leaving the User bank (GPIO0 to GPIO29) for the programmer to use. All GPIOs support digital input and output, but GPIO26 to GPIO29 can also be used as inputs to the chipâ€™s Analogue to Digital Converter (ADC). Each GPIO can be controlled directly by software running on the processors, or by a number of other functional blocks.</p>
<p >The function allocated to each GPIO is selected by calling the <a class="el" href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">gpio_set_function</a> function. </p><dl class="section note"><dt>Note</dt><dd>Not all functions are available on all pins.</dd></dl>
<p>Each GPIO can have one function selected at a time. Likewise, each peripheral input (e.g. UART0 RX) should only be selected on one <em>GPIO</em> at a time. If the same peripheral input is connected to multiple GPIOs, the peripheral sees the logical OR of these GPIO inputs. Please refer to the datasheet for more information on GPIO function select.</p>
<h3><a class="anchor" id="autotoc_md0"></a>
Function Select Table</h3>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">GPIO   </th><th class="markdownTableHeadNone">F1   </th><th class="markdownTableHeadNone">F2   </th><th class="markdownTableHeadNone">F3   </th><th class="markdownTableHeadNone">F4   </th><th class="markdownTableHeadNone">F5   </th><th class="markdownTableHeadNone">F6   </th><th class="markdownTableHeadNone">F7   </th><th class="markdownTableHeadNone">F8   </th><th class="markdownTableHeadNone">F9    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">0   </td><td class="markdownTableBodyNone">SPI0 RX   </td><td class="markdownTableBodyNone">UART0 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM0 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1   </td><td class="markdownTableBodyNone">SPI0 CSn   </td><td class="markdownTableBodyNone">UART0 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM0 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">2   </td><td class="markdownTableBodyNone">SPI0 SCK   </td><td class="markdownTableBodyNone">UART0 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM1 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">3   </td><td class="markdownTableBodyNone">SPI0 TX   </td><td class="markdownTableBodyNone">UART0 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM1 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">4   </td><td class="markdownTableBodyNone">SPI0 RX   </td><td class="markdownTableBodyNone">UART1 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM2 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">5   </td><td class="markdownTableBodyNone">SPI0 CSn   </td><td class="markdownTableBodyNone">UART1 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM2 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">6   </td><td class="markdownTableBodyNone">SPI0 SCK   </td><td class="markdownTableBodyNone">UART1 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM3 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">7   </td><td class="markdownTableBodyNone">SPI0 TX   </td><td class="markdownTableBodyNone">UART1 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM3 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">8   </td><td class="markdownTableBodyNone">SPI1 RX   </td><td class="markdownTableBodyNone">UART1 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM4 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">9   </td><td class="markdownTableBodyNone">SPI1 CSn   </td><td class="markdownTableBodyNone">UART1 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM4 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10   </td><td class="markdownTableBodyNone">SPI1 SCK   </td><td class="markdownTableBodyNone">UART1 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM5 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">11   </td><td class="markdownTableBodyNone">SPI1 TX   </td><td class="markdownTableBodyNone">UART1 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM5 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">12   </td><td class="markdownTableBodyNone">SPI1 RX   </td><td class="markdownTableBodyNone">UART0 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM6 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">13   </td><td class="markdownTableBodyNone">SPI1 CSn   </td><td class="markdownTableBodyNone">UART0 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM6 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">14   </td><td class="markdownTableBodyNone">SPI1 SCK   </td><td class="markdownTableBodyNone">UART0 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM7 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">15   </td><td class="markdownTableBodyNone">SPI1 TX   </td><td class="markdownTableBodyNone">UART0 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM7 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">16   </td><td class="markdownTableBodyNone">SPI0 RX   </td><td class="markdownTableBodyNone">UART0 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM0 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">17   </td><td class="markdownTableBodyNone">SPI0 CSn   </td><td class="markdownTableBodyNone">UART0 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM0 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">18   </td><td class="markdownTableBodyNone">SPI0 SCK   </td><td class="markdownTableBodyNone">UART0 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM1 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">19   </td><td class="markdownTableBodyNone">SPI0 TX   </td><td class="markdownTableBodyNone">UART0 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM1 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">20   </td><td class="markdownTableBodyNone">SPI0 RX   </td><td class="markdownTableBodyNone">UART1 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM2 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPIN0   </td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">21   </td><td class="markdownTableBodyNone">SPI0 CSn   </td><td class="markdownTableBodyNone">UART1 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM2 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPOUT0   </td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">22   </td><td class="markdownTableBodyNone">SPI0 SCK   </td><td class="markdownTableBodyNone">UART1 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM3 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPIN1   </td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">23   </td><td class="markdownTableBodyNone">SPI0 TX   </td><td class="markdownTableBodyNone">UART1 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM3 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPOUT1   </td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">24   </td><td class="markdownTableBodyNone">SPI1 RX   </td><td class="markdownTableBodyNone">UART1 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM4 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPOUT2   </td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">25   </td><td class="markdownTableBodyNone">SPI1 CSn   </td><td class="markdownTableBodyNone">UART1 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM4 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone">CLOCK GPOUT3   </td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">26   </td><td class="markdownTableBodyNone">SPI1 SCK   </td><td class="markdownTableBodyNone">UART1 CTS   </td><td class="markdownTableBodyNone">I2C1 SDA   </td><td class="markdownTableBodyNone">PWM5 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">27   </td><td class="markdownTableBodyNone">SPI1 TX   </td><td class="markdownTableBodyNone">UART1 RTS   </td><td class="markdownTableBodyNone">I2C1 SCL   </td><td class="markdownTableBodyNone">PWM5 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB OVCUR DET    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">28   </td><td class="markdownTableBodyNone">SPI1 RX   </td><td class="markdownTableBodyNone">UART0 TX   </td><td class="markdownTableBodyNone">I2C0 SDA   </td><td class="markdownTableBodyNone">PWM6 A   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS DET    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">29   </td><td class="markdownTableBodyNone">SPI1 CSn   </td><td class="markdownTableBodyNone">UART0 RX   </td><td class="markdownTableBodyNone">I2C0 SCL   </td><td class="markdownTableBodyNone">PWM6 B   </td><td class="markdownTableBodyNone">SIO   </td><td class="markdownTableBodyNone">PIO0   </td><td class="markdownTableBodyNone">PIO1   </td><td class="markdownTableBodyNone"></td><td class="markdownTableBodyNone">USB VBUS EN   </td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga8fcdfeff45cc2030530bf00c6ae1e0a3" name="ga8fcdfeff45cc2030530bf00c6ae1e0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fcdfeff45cc2030530bf00c6ae1e0a3">&#9670;&nbsp;</a></span>gpio_irq_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* gpio_irq_callback_t) (uint gpio, uint32_t event_mask)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function type for GPIO events</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>Which GPIO caused this interrupt </td></tr>
    <tr><td class="paramname">event_mask</td><td>Which events caused this interrupt. See <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga6165f07f4b619dd08ea6dc97d069e78a" title="Convenience function which performs multiple GPIO IRQ related initializations.">gpio_set_irq_enabled_with_callback()</a> </dd>
<dd>
<a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb" title="Set the generic callback used for GPIO IRQ events for the current core.">gpio_set_irq_callback()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga14eba84c1c8f80b08a770775d3bf060a" name="ga14eba84c1c8f80b08a770775d3bf060a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14eba84c1c8f80b08a770775d3bf060a">&#9670;&nbsp;</a></span>gpio_drive_strength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Drive strength levels for GPIO outputs. </p>
<p >Drive strength levels for GPIO outputs. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga0ffe0ddabcd081b513731275df97e7ca" title="Set drive strength for a specified GPIO.">gpio_set_drive_strength</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga14eba84c1c8f80b08a770775d3bf060aa04d31285e4f4921102485e775e55e295" name="gga14eba84c1c8f80b08a770775d3bf060aa04d31285e4f4921102485e775e55e295"></a>GPIO_DRIVE_STRENGTH_2MA&#160;</td><td class="fielddoc"><p >2 mA nominal drive strength </p>
</td></tr>
<tr><td class="fieldname"><a id="gga14eba84c1c8f80b08a770775d3bf060aa5c9d0b430fd44ee7688d58cf94f47de6" name="gga14eba84c1c8f80b08a770775d3bf060aa5c9d0b430fd44ee7688d58cf94f47de6"></a>GPIO_DRIVE_STRENGTH_4MA&#160;</td><td class="fielddoc"><p >4 mA nominal drive strength </p>
</td></tr>
<tr><td class="fieldname"><a id="gga14eba84c1c8f80b08a770775d3bf060aa3cc28353572b5f8e8bb2eb80f884a98d" name="gga14eba84c1c8f80b08a770775d3bf060aa3cc28353572b5f8e8bb2eb80f884a98d"></a>GPIO_DRIVE_STRENGTH_8MA&#160;</td><td class="fielddoc"><p >8 mA nominal drive strength </p>
</td></tr>
<tr><td class="fieldname"><a id="gga14eba84c1c8f80b08a770775d3bf060aa418f6be7649c316bab248b91c2eb1716" name="gga14eba84c1c8f80b08a770775d3bf060aa418f6be7649c316bab248b91c2eb1716"></a>GPIO_DRIVE_STRENGTH_12MA&#160;</td><td class="fielddoc"><p >12 mA nominal drive strength </p>
</td></tr>
</table>

</div>
</div>
<a id="ga2af81373f9f5764ac1a5bd6097477530" name="ga2af81373f9f5764ac1a5bd6097477530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2af81373f9f5764ac1a5bd6097477530">&#9670;&nbsp;</a></span>gpio_function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO function definitions for use with function select. </p>
<p >GPIO function selectors</p>
<p >Each GPIO can have one function selected at a time. Likewise, each peripheral input (e.g. UART0 RX) should only be selected on one GPIO at a time. If the same peripheral input is connected to multiple GPIOs, the peripheral sees the logical OR of these GPIO inputs.</p>
<p >Please refer to the datasheet for more information on GPIO function selection. </p>

</div>
</div>
<a id="ga6347e27da3ab34f1ea65b5ae16ab724f" name="ga6347e27da3ab34f1ea65b5ae16ab724f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6347e27da3ab34f1ea65b5ae16ab724f">&#9670;&nbsp;</a></span>gpio_irq_level</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GPIO Interrupt level definitions (GPIO events) </p>
<p >GPIO Interrupt levels</p>
<p >An interrupt can be generated for every GPIO pin in 4 scenarios:</p>
<ul>
<li>Level High: the GPIO pin is a logical 1</li>
<li>Level Low: the GPIO pin is a logical 0</li>
<li>Edge High: the GPIO has transitioned from a logical 0 to a logical 1</li>
<li>Edge Low: the GPIO has transitioned from a logical 1 to a logical 0</li>
</ul>
<p >The level interrupts are not latched. This means that if the pin is a logical 1 and the level high interrupt is active, it will become inactive as soon as the pin changes to a logical 0. The edge interrupts are stored in the INTR register and can be cleared by writing to the INTR register. </p>

</div>
</div>
<a id="ga72c250c9393043ea5beb56092d26e229" name="ga72c250c9393043ea5beb56092d26e229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72c250c9393043ea5beb56092d26e229">&#9670;&nbsp;</a></span>gpio_slew_rate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Slew rate limiting levels for GPIO outputs. </p>
<p >Slew rate limiting increases the minimum rise/fall time when a GPIO output is lightly loaded, which can help to reduce electromagnetic emissions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#gaf1d12efbed0809650d98fe9a424876c8" title="Set slew rate for a specified GPIO.">gpio_set_slew_rate</a> </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga72c250c9393043ea5beb56092d26e229a6173e20f5be765a136661c48f9766634" name="gga72c250c9393043ea5beb56092d26e229a6173e20f5be765a136661c48f9766634"></a>GPIO_SLEW_RATE_SLOW&#160;</td><td class="fielddoc"><p >Slew rate limiting enabled. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga72c250c9393043ea5beb56092d26e229a44b116ac7ac70a405c952a6054a1eade" name="gga72c250c9393043ea5beb56092d26e229a44b116ac7ac70a405c952a6054a1eade"></a>GPIO_SLEW_RATE_FAST&#160;</td><td class="fielddoc"><p >Slew rate limiting disabled. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga091c148a5cfaf2b55e716b6effef6360" name="ga091c148a5cfaf2b55e716b6effef6360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga091c148a5cfaf2b55e716b6effef6360">&#9670;&nbsp;</a></span>gpio_acknowledge_irq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_acknowledge_irq </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acknowledge a GPIO interrupt for the specified events on the calling core. </p>
<dl class="section note"><dt>Note</dt><dd>This may be called with a mask of any of valid bits specified in <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a>, however it has no effect on <em>level</em> sensitive interrupts which remain pending while the GPIO is at the specified level. When handling <em>level</em> sensitive interrupts, you should generally disable the interrupt (see <a class="el" href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">gpio_set_irq_enabled</a>) and then set it up again later once the GPIO level has changed (or to catch the opposite level).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For callbacks set with <a class="el" href="group__hardware__gpio.html#ga6165f07f4b619dd08ea6dc97d069e78a">gpio_set_irq_enabled_with_callback</a>, or <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>, this function is called automatically. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event_mask</td><td>Bitmask of events to clear. See <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2e78fcd487a3a2e173322c6502fe9419" name="ga2e78fcd487a3a2e173322c6502fe9419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e78fcd487a3a2e173322c6502fe9419">&#9670;&nbsp;</a></span>gpio_add_raw_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_add_raw_irq_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a raw GPIO IRQ handler for a specific GPIO on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.</p>
<p >This method adds such a callback, and disables the "default" callback for the specified GPIO.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple raw handlers should not be added for the same GPIO, and this method will assert if you attempt to.</dd></dl>
<p>A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_irq_handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num) &amp; my_gpio_event_mask) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num, my_gpio_event_mask);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__hardware__gpio_html_ga091c148a5cfaf2b55e716b6effef6360"><div class="ttname"><a href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a></div><div class="ttdeci">void gpio_acknowledge_irq(uint gpio, uint32_t events)</div><div class="ttdoc">Acknowledge a GPIO interrupt for the specified events on the calling core.</div><div class="ttdef"><b>Definition:</b> gpio.c:225</div></div>
<div class="ttc" id="agroup__hardware__gpio_html_gaf2d1208ba7e3b02b23e7385350182583"><div class="ttname"><a href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a></div><div class="ttdeci">static uint32_t gpio_get_irq_event_mask(uint gpio)</div><div class="ttdoc">Return the current interrupt status (pending events) for the given GPIO.</div><div class="ttdef"><b>Definition:</b> gpio.h:461</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>the GPIO number that will no longer be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to add to the list of GPIO IRQ handlers for this core </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37ab6047475687869bd84d90e183e09f" name="ga37ab6047475687869bd84d90e183e09f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37ab6047475687869bd84d90e183e09f">&#9670;&nbsp;</a></span>gpio_add_raw_irq_handler_masked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_add_raw_irq_handler_masked </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a raw GPIO IRQ handler for the specified GPIOs on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.</p>
<p >This method adds such a callback, and disables the "default" callback for the specified GPIOs.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.</dd></dl>
<p>A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_irq_handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num) &amp; my_gpio_event_mask) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num, my_gpio_event_mask);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num2) &amp; my_gpio_event_mask2) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num2, my_gpio_event_mask2);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio_mask</td><td>a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to add to the list of GPIO IRQ handlers for this core </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga07c4de2660686b9158a5b0526ccbb446" name="ga07c4de2660686b9158a5b0526ccbb446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07c4de2660686b9158a5b0526ccbb446">&#9670;&nbsp;</a></span>gpio_add_raw_irq_handler_with_order_priority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_add_raw_irq_handler_with_order_priority </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>order_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a raw GPIO IRQ handler for a specific GPIO on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default callback. The order relative to the default callback can be controlled via the order_priority parameter(the default callback has the priority GPIO_IRQ_CALLBACK_ORDER_PRIORITY which defaults to the lowest priority with the intention of it running last).</p>
<p >This method adds such a callback, and disables the "default" callback for the specified GPIO.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple raw handlers should not be added for the same GPIO, and this method will assert if you attempt to.</dd></dl>
<p>A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_irq_handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num) &amp; my_gpio_event_mask) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num, my_gpio_event_mask);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>the GPIO number that will no longer be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to add to the list of GPIO IRQ handlers for this core </td></tr>
    <tr><td class="paramname">order_priority</td><td>the priority order to determine the relative position of the handler in the list of GPIO IRQ handlers for this core. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga213978aec060f04ce3a674849c999b45" name="ga213978aec060f04ce3a674849c999b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga213978aec060f04ce3a674849c999b45">&#9670;&nbsp;</a></span>gpio_add_raw_irq_handler_with_order_priority_masked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_add_raw_irq_handler_with_order_priority_masked </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>order_priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a raw GPIO IRQ handler for the specified GPIOs on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default callback. The order relative to the default callback can be controlled via the order_priority parameter (the default callback has the priority GPIO_IRQ_CALLBACK_ORDER_PRIORITY which defaults to the lowest priority with the intention of it running last).</p>
<p >This method adds such an explicit GPIO IRQ handler, and disables the "default" callback for the specified GPIOs.</p>
<dl class="section note"><dt>Note</dt><dd>Multiple raw handlers should not be added for the same GPIOs, and this method will assert if you attempt to.</dd></dl>
<p>A raw handler should check for whichever GPIOs and events it handles, and acknowledge them itself; it might look something like:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> my_irq_handler(<span class="keywordtype">void</span>) {</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num) &amp; my_gpio_event_mask) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num, my_gpio_event_mask);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code hl_function" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>(my_gpio_num2) &amp; my_gpio_event_mask2) {</div>
<div class="line">       <a class="code hl_function" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360">gpio_acknowledge_irq</a>(my_gpio_num2, my_gpio_event_mask2);</div>
<div class="line">      <span class="comment">// handle the IRQ</span></div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio_mask</td><td>a bit mask of the GPIO numbers that will no longer be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to add to the list of GPIO IRQ handlers for this core </td></tr>
    <tr><td class="paramname">order_priority</td><td>the priority order to determine the relative position of the handler in the list of GPIO IRQ handlers for this core. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6aca495d644a6ae66050a99ef44defbe" name="ga6aca495d644a6ae66050a99ef44defbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6aca495d644a6ae66050a99ef44defbe">&#9670;&nbsp;</a></span>gpio_clr_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_clr_mask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive low every GPIO appearing in mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO values to clear, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4df18d737955c17a65c5a94412826674" name="ga4df18d737955c17a65c5a94412826674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df18d737955c17a65c5a94412826674">&#9670;&nbsp;</a></span>gpio_deinit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_deinit </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets a GPIO back to the NULL function, i.e. disables it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae57a625b7e0bcac6d596f35864ffc792" name="gae57a625b7e0bcac6d596f35864ffc792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae57a625b7e0bcac6d596f35864ffc792">&#9670;&nbsp;</a></span>gpio_disable_pulls()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_disable_pulls </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Disable pulls on specified GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf38c0b39fba06d1a49d1be56ef548d73" name="gaf38c0b39fba06d1a49d1be56ef548d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf38c0b39fba06d1a49d1be56ef548d73">&#9670;&nbsp;</a></span>gpio_get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gpio_get </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get state of a single specified GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current state of the GPIO. 0 for low, non-zero for high </dd></dl>

</div>
</div>
<a id="gae895be2d3c5af5df460150eafe7858a4" name="gae895be2d3c5af5df460150eafe7858a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae895be2d3c5af5df460150eafe7858a4">&#9670;&nbsp;</a></span>gpio_get_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t gpio_get_all </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get raw value of all GPIOs. </p>
<dl class="section return"><dt>Returns</dt><dd>Bitmask of raw GPIO values, as bits 0-29 </dd></dl>

</div>
</div>
<a id="ga2a78dd5d9b2a181794c632aa4881c5ed" name="ga2a78dd5d9b2a181794c632aa4881c5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a78dd5d9b2a181794c632aa4881c5ed">&#9670;&nbsp;</a></span>gpio_get_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint gpio_get_dir </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a specific GPIO direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 for out, 0 for in </dd></dl>

</div>
</div>
<a id="ga1378540c24ec318ac7674dac4ec30140" name="ga1378540c24ec318ac7674dac4ec30140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1378540c24ec318ac7674dac4ec30140">&#9670;&nbsp;</a></span>gpio_get_drive_strength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a> gpio_get_drive_strength </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current slew rate for a specified GPIO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga0ffe0ddabcd081b513731275df97e7ca" title="Set drive strength for a specified GPIO.">gpio_set_drive_strength</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current drive strength of that GPIO </dd></dl>

</div>
</div>
<a id="gac41d97649605d14d3e176e72d432c01a" name="gac41d97649605d14d3e176e72d432c01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac41d97649605d14d3e176e72d432c01a">&#9670;&nbsp;</a></span>gpio_get_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a> gpio_get_function </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current GPIO function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Which GPIO function is currently selected from list <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a> </dd></dl>

</div>
</div>
<a id="gaf2d1208ba7e3b02b23e7385350182583" name="gaf2d1208ba7e3b02b23e7385350182583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2d1208ba7e3b02b23e7385350182583">&#9670;&nbsp;</a></span>gpio_get_irq_event_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t gpio_get_irq_event_mask </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current interrupt status (pending events) for the given GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitmask of events that are currently pending for the GPIO. See <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> for details. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga091c148a5cfaf2b55e716b6effef6360" title="Acknowledge a GPIO interrupt for the specified events on the calling core.">gpio_acknowledge_irq</a> </dd></dl>

</div>
</div>
<a id="ga0a818ceaa50e3e2317fbb0856d47eaef" name="ga0a818ceaa50e3e2317fbb0856d47eaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a818ceaa50e3e2317fbb0856d47eaef">&#9670;&nbsp;</a></span>gpio_get_out_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gpio_get_out_level </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine whether a GPIO is currently driven high or low. </p>
<p >This function returns the high/low output level most recently assigned to a GPIO via <a class="el" href="group__hardware__gpio.html#ga71d35b29e897b9bb4fc881b587b08cab" title="Drive a single GPIO high/low.">gpio_put()</a> or similar. This is the value that is presented outward to the IO muxing, <em>not</em> the input level back from the pad (which can be read using <a class="el" href="group__hardware__gpio.html#gaf38c0b39fba06d1a49d1be56ef548d73" title="Get state of a single specified GPIO.">gpio_get()</a>).</p>
<p >To avoid races, this function must not be used for read-modify-write sequences when driving GPIOs &ndash; instead functions like <a class="el" href="group__hardware__gpio.html#ga71d35b29e897b9bb4fc881b587b08cab" title="Drive a single GPIO high/low.">gpio_put()</a> should be used to atomically update GPIOs. This accessor is intended for debug use only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the GPIO output level is high, false if low. </dd></dl>

</div>
</div>
<a id="ga4422d9c09199d199e8fe736b3c29ae49" name="ga4422d9c09199d199e8fe736b3c29ae49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4422d9c09199d199e8fe736b3c29ae49">&#9670;&nbsp;</a></span>gpio_get_slew_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a> gpio_get_slew_rate </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine current slew rate for a specified GPIO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#gaf1d12efbed0809650d98fe9a424876c8" title="Set slew rate for a specified GPIO.">gpio_set_slew_rate</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current slew rate of that GPIO </dd></dl>

</div>
</div>
<a id="ga8aa4741d93dc40bc728dbd3e41813ad1" name="ga8aa4741d93dc40bc728dbd3e41813ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aa4741d93dc40bc728dbd3e41813ad1">&#9670;&nbsp;</a></span>gpio_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_init </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a GPIO for (enabled I/O and set func to GPIO_FUNC_SIO) </p>
<p >Clear the output enable (i.e. set to input). Clear any output value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f3ccb15297fecd3792359d9cbbf6ed6" name="ga2f3ccb15297fecd3792359d9cbbf6ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f3ccb15297fecd3792359d9cbbf6ed6">&#9670;&nbsp;</a></span>gpio_init_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_init_mask </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio_mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise multiple GPIOs (enabled I/O and set func to GPIO_FUNC_SIO) </p>
<p >Clear the output enable (i.e. set to input). Clear any output value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio_mask</td><td>Mask with 1 bit per GPIO number to initialize </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa0dbc5c65103d483217a190b72ed26dc" name="gaa0dbc5c65103d483217a190b72ed26dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0dbc5c65103d483217a190b72ed26dc">&#9670;&nbsp;</a></span>gpio_is_dir_out()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gpio_is_dir_out </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a specific GPIO direction is OUT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the direction for the pin is OUT </dd></dl>

</div>
</div>
<a id="gac451f3251c0d0bea97aa535f65974ec8" name="gac451f3251c0d0bea97aa535f65974ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac451f3251c0d0bea97aa535f65974ec8">&#9670;&nbsp;</a></span>gpio_is_input_hysteresis_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool gpio_is_input_hysteresis_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether input hysteresis is enabled on a specified GPIO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga1f52eecc12d4348ef8bd1e17bdb4b107" title="Enable/disable GPIO input hysteresis (Schmitt trigger)">gpio_set_input_hysteresis_enabled</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54c35d7beb7025aa001ae5b93d38935b" name="ga54c35d7beb7025aa001ae5b93d38935b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54c35d7beb7025aa001ae5b93d38935b">&#9670;&nbsp;</a></span>gpio_is_pulled_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gpio_is_pulled_down </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the specified GPIO is pulled down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the GPIO is pulled down </dd></dl>

</div>
</div>
<a id="gac7038968884d02b67403a50f1be6ecd6" name="gac7038968884d02b67403a50f1be6ecd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7038968884d02b67403a50f1be6ecd6">&#9670;&nbsp;</a></span>gpio_is_pulled_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool gpio_is_pulled_up </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the specified GPIO is pulled up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the GPIO is pulled up </dd></dl>

</div>
</div>
<a id="gaea499c33479cf8f87a91a74411ad241f" name="gaea499c33479cf8f87a91a74411ad241f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea499c33479cf8f87a91a74411ad241f">&#9670;&nbsp;</a></span>gpio_pull_down()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_pull_down </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set specified GPIO to be pulled down. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga30a6733240f3d2e25e6b579b6c3902da" name="ga30a6733240f3d2e25e6b579b6c3902da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30a6733240f3d2e25e6b579b6c3902da">&#9670;&nbsp;</a></span>gpio_pull_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_pull_up </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set specified GPIO to be pulled up. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga71d35b29e897b9bb4fc881b587b08cab" name="ga71d35b29e897b9bb4fc881b587b08cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71d35b29e897b9bb4fc881b587b08cab">&#9670;&nbsp;</a></span>gpio_put()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_put </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive a single GPIO high/low. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">value</td><td>If false clear the GPIO, otherwise set it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7aa41e10d04a8d99d9a8c4d7ba5007b8" name="ga7aa41e10d04a8d99d9a8c4d7ba5007b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aa41e10d04a8d99d9a8c4d7ba5007b8">&#9670;&nbsp;</a></span>gpio_put_all()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_put_all </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive all pins simultaneously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Bitmask of GPIO values to change, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac86436d117c7a87f982c9b3311543302" name="gac86436d117c7a87f982c9b3311543302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac86436d117c7a87f982c9b3311543302">&#9670;&nbsp;</a></span>gpio_put_masked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_put_masked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive GPIO high/low depending on parameters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO values to change, as bits 0-29 </td></tr>
    <tr><td class="paramname">value</td><td>Value to set</td></tr>
  </table>
  </dd>
</dl>
<p>For each 1 bit in <code>mask</code>, drive that pin to the value given by corresponding bit in <code>value</code>, leaving other pins unchanged. Since this uses the TOGL alias, it is concurrency-safe with e.g. an IRQ bashing different pins from the same core. </p>

</div>
</div>
<a id="ga495c253b01a68b0f81721d2061741243" name="ga495c253b01a68b0f81721d2061741243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga495c253b01a68b0f81721d2061741243">&#9670;&nbsp;</a></span>gpio_remove_raw_irq_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_remove_raw_irq_handler </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a raw GPIO IRQ handler for the specified GPIO on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.</p>
<p >This method removes such a callback, and enables the "default" callback for the specified GPIO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>the GPIO number that will now be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to remove from the list of GPIO IRQ handlers for this core </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafb77622d0cd387bea253f10d8165c45e" name="gafb77622d0cd387bea253f10d8165c45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb77622d0cd387bea253f10d8165c45e">&#9670;&nbsp;</a></span>gpio_remove_raw_irq_handler_masked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_remove_raw_irq_handler_masked </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__irq.html#ga8478ee26cc144e947ccd75b0169059a6">irq_handler_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a raw GPIO IRQ handler for the specified GPIOs on the current core. </p>
<p >In addition to the default mechanism of a single GPIO IRQ event callback per core (see <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>), it is possible to add explicit GPIO IRQ handlers which are called independent of the default event callback.</p>
<p >This method removes such a callback, and enables the "default" callback for the specified GPIOs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio_mask</td><td>a bit mask of the GPIO numbers that will now be passed to the default callback for this core </td></tr>
    <tr><td class="paramname">handler</td><td>the handler to remove from the list of GPIO IRQ handlers for this core </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6a40edf0d86f6b3f0dcb51a768cf4681" name="ga6a40edf0d86f6b3f0dcb51a768cf4681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a40edf0d86f6b3f0dcb51a768cf4681">&#9670;&nbsp;</a></span>gpio_set_dir()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_dir </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single GPIO direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">out</td><td>true for out, false for in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga50b526aa81f036a20c60f04106910578" name="ga50b526aa81f036a20c60f04106910578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50b526aa81f036a20c60f04106910578">&#9670;&nbsp;</a></span>gpio_set_dir_all_bits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_dir_all_bits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set direction of all pins simultaneously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">values</td><td>individual settings for each gpio; for GPIO N, bit N is 1 for out, 0 for in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79819a97822983d7422d37c3e532cc53" name="ga79819a97822983d7422d37c3e532cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79819a97822983d7422d37c3e532cc53">&#9670;&nbsp;</a></span>gpio_set_dir_in_masked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_dir_in_masked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a number of GPIOs to input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO to set to input, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa64fdceff54dda03f4427f04c2f9ced2" name="gaa64fdceff54dda03f4427f04c2f9ced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa64fdceff54dda03f4427f04c2f9ced2">&#9670;&nbsp;</a></span>gpio_set_dir_masked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_dir_masked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set multiple GPIO directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO to set to input, as bits 0-29 </td></tr>
    <tr><td class="paramname">value</td><td>Values to set</td></tr>
  </table>
  </dd>
</dl>
<p>For each 1 bit in "mask", switch that pin to the direction given by corresponding bit in "value", leaving other pins unchanged. E.g. gpio_set_dir_masked(0x3, 0x2); -&gt; set pin 0 to input, pin 1 to output, simultaneously. </p>

</div>
</div>
<a id="ga7b2cc867ac41996100e881a768c7f969" name="ga7b2cc867ac41996100e881a768c7f969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b2cc867ac41996100e881a768c7f969">&#9670;&nbsp;</a></span>gpio_set_dir_out_masked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_dir_out_masked </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a number of GPIOs to output. </p>
<p >Switch all GPIOs in "mask" to output</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO to set to output, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0b10ec79e10d7df958373b178debcd2e" name="ga0b10ec79e10d7df958373b178debcd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b10ec79e10d7df958373b178debcd2e">&#9670;&nbsp;</a></span>gpio_set_dormant_irq_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_dormant_irq_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable dormant wake up interrupt for specified GPIO and events. </p>
<p >This configures IRQs to restart the XOSC or ROSC when they are disabled in dormant mode</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">event_mask</td><td>Which events will cause an interrupt. See <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> for details. </td></tr>
    <tr><td class="paramname">enabled</td><td>Enable/disable flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0ffe0ddabcd081b513731275df97e7ca" name="ga0ffe0ddabcd081b513731275df97e7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ffe0ddabcd081b513731275df97e7ca">&#9670;&nbsp;</a></span>gpio_set_drive_strength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_drive_strength </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__hardware__gpio.html#ga14eba84c1c8f80b08a770775d3bf060a">gpio_drive_strength</a>&#160;</td>
          <td class="paramname"><em>drive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set drive strength for a specified GPIO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga1378540c24ec318ac7674dac4ec30140" title="Determine current slew rate for a specified GPIO.">gpio_get_drive_strength</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">drive</td><td>GPIO output drive strength </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacde9174277ca40aa7b6fdd341bb2b8c" name="gaacde9174277ca40aa7b6fdd341bb2b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacde9174277ca40aa7b6fdd341bb2b8c">&#9670;&nbsp;</a></span>gpio_set_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_function </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a>&#160;</td>
          <td class="paramname"><em>fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select GPIO function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">fn</td><td>Which GPIO function select to use from list <a class="el" href="group__hardware__gpio.html#ga2af81373f9f5764ac1a5bd6097477530">gpio_function</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6037bdaf406a84336043c9a6c40e5073" name="ga6037bdaf406a84336043c9a6c40e5073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6037bdaf406a84336043c9a6c40e5073">&#9670;&nbsp;</a></span>gpio_set_inover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_inover </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select GPIO input override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">value</td><td>See <a class="el" href="gpio_8h.html#a760c408911eb8aaad767d39df9e4e990">gpio_override</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74a8c3e55185581bc3df335aea1d0fb8" name="ga74a8c3e55185581bc3df335aea1d0fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74a8c3e55185581bc3df335aea1d0fb8">&#9670;&nbsp;</a></span>gpio_set_input_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_input_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable GPIO input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable input on specified GPIO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1f52eecc12d4348ef8bd1e17bdb4b107" name="ga1f52eecc12d4348ef8bd1e17bdb4b107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f52eecc12d4348ef8bd1e17bdb4b107">&#9670;&nbsp;</a></span>gpio_set_input_hysteresis_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_input_hysteresis_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable GPIO input hysteresis (Schmitt trigger) </p>
<p >Enable or disable the Schmitt trigger hysteresis on a given GPIO. This is enabled on all GPIOs by default. Disabling input hysteresis can lead to inconsistent readings when the input signal has very long rise or fall times, but slightly reduces the GPIO's input delay.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#gac451f3251c0d0bea97aa535f65974ec8" title="Determine whether input hysteresis is enabled on a specified GPIO.">gpio_is_input_hysteresis_enabled</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable input hysteresis on specified GPIO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga37b23dea291af5926735b5e8c87b7dbb" name="ga37b23dea291af5926735b5e8c87b7dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37b23dea291af5926735b5e8c87b7dbb">&#9670;&nbsp;</a></span>gpio_set_irq_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_irq_callback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__hardware__gpio.html#ga8fcdfeff45cc2030530bf00c6ae1e0a3">gpio_irq_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the generic callback used for GPIO IRQ events for the current core. </p>
<p >This function sets the callback used for all GPIO IRQs on the current core that are not explicitly hooked via <a class="el" href="group__hardware__gpio.html#ga2e78fcd487a3a2e173322c6502fe9419">gpio_add_raw_irq_handler</a> or other gpio_add_raw_irq_handler_ functions.</p>
<p >This function is called with the GPIO number and event mask for each of the (not explicitly hooked) GPIOs that have events enabled and that are pending (see <a class="el" href="group__hardware__gpio.html#gaf2d1208ba7e3b02b23e7385350182583">gpio_get_irq_event_mask</a>).</p>
<dl class="section note"><dt>Note</dt><dd>The IO IRQs are independent per-processor. This function affects the processor that calls the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>default user function to call on GPIO irq. Note only one of these can be set per processor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga08b1f920beba446c4d4385de999cf945" name="ga08b1f920beba446c4d4385de999cf945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08b1f920beba446c4d4385de999cf945">&#9670;&nbsp;</a></span>gpio_set_irq_enabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_irq_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable specific interrupt events for specified GPIO. </p>
<p >This function sets which GPIO events cause a GPIO interrupt on the calling core. See <a class="el" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>, <a class="el" href="group__hardware__gpio.html#ga6165f07f4b619dd08ea6dc97d069e78a">gpio_set_irq_enabled_with_callback</a> and <a class="el" href="group__hardware__gpio.html#ga2e78fcd487a3a2e173322c6502fe9419">gpio_add_raw_irq_handler</a> to set up a GPIO interrupt handler to handle the events.</p>
<dl class="section note"><dt>Note</dt><dd>The IO IRQs are independent per-processor. This configures the interrupt events for the processor that calls the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">event_mask</td><td>Which events will cause an interrupt </td></tr>
    <tr><td class="paramname">enabled</td><td>Enable or disable flag</td></tr>
  </table>
  </dd>
</dl>
<p>Events is a bitmask of the following <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> values:</p>
<p >bit | constant | interrupt -&mdash;|-------------------------------------------------------&mdash; 0 | GPIO_IRQ_LEVEL_LOW | Continuously while level is low 1 | GPIO_IRQ_LEVEL_HIGH | Continuously while level is high 2 | GPIO_IRQ_EDGE_FALL | On each transition from high to low 3 | GPIO_IRQ_EDGE_RISE | On each transition from low to high</p>
<p >which are specified in <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> </p>

</div>
</div>
<a id="ga6165f07f4b619dd08ea6dc97d069e78a" name="ga6165f07f4b619dd08ea6dc97d069e78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6165f07f4b619dd08ea6dc97d069e78a">&#9670;&nbsp;</a></span>gpio_set_irq_enabled_with_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_irq_enabled_with_callback </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>event_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__hardware__gpio.html#ga8fcdfeff45cc2030530bf00c6ae1e0a3">gpio_irq_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience function which performs multiple GPIO IRQ related initializations. </p>
<p >This method is a slightly eclectic mix of initialization, that:</p>
<ul>
<li>Updates whether the specified events for the specified GPIO causes an interrupt on the calling core based on the enable flag.</li>
</ul>
<ul>
<li>Sets the callback handler for the calling core to callback (or clears the handler if the callback is NULL).</li>
</ul>
<ul>
<li>Enables GPIO IRQs on the current core if enabled is true.</li>
</ul>
<p>This method is commonly used to perform a one time setup, and following that any additional IRQs/events are enabled via <a class="el" href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">gpio_set_irq_enabled</a>. All GPIOs/events added in this way on the same core share the same callback; for multiple independent handlers for different GPIOs you should use <a class="el" href="group__hardware__gpio.html#ga2e78fcd487a3a2e173322c6502fe9419">gpio_add_raw_irq_handler</a> and related functions.</p>
<p >This method is equivalent to:</p>
<div class="fragment"><div class="line"><a class="code hl_function" href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">gpio_set_irq_enabled</a>(gpio, event_mask, enabled);</div>
<div class="line"><a class="code hl_function" href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a>(callback);</div>
<div class="line"><span class="keywordflow">if</span> (enabled) <a class="code hl_function" href="group__hardware__irq.html#ga7c7167f643c6898b758340ce59d333d9">irq_set_enabled</a>(IO_IRQ_BANK0, <span class="keyword">true</span>);</div>
<div class="ttc" id="agroup__hardware__gpio_html_ga08b1f920beba446c4d4385de999cf945"><div class="ttname"><a href="group__hardware__gpio.html#ga08b1f920beba446c4d4385de999cf945">gpio_set_irq_enabled</a></div><div class="ttdeci">void gpio_set_irq_enabled(uint gpio, uint32_t events, bool enabled)</div><div class="ttdoc">Enable or disable specific interrupt events for specified GPIO.</div><div class="ttdef"><b>Definition:</b> gpio.c:176</div></div>
<div class="ttc" id="agroup__hardware__gpio_html_ga37b23dea291af5926735b5e8c87b7dbb"><div class="ttname"><a href="group__hardware__gpio.html#ga37b23dea291af5926735b5e8c87b7dbb">gpio_set_irq_callback</a></div><div class="ttdeci">void gpio_set_irq_callback(gpio_irq_callback_t callback)</div><div class="ttdoc">Set the generic callback used for GPIO IRQ events for the current core.</div><div class="ttdef"><b>Definition:</b> gpio.c:190</div></div>
<div class="ttc" id="agroup__hardware__irq_html_ga7c7167f643c6898b758340ce59d333d9"><div class="ttname"><a href="group__hardware__irq.html#ga7c7167f643c6898b758340ce59d333d9">irq_set_enabled</a></div><div class="ttdeci">void irq_set_enabled(uint num, bool enabled)</div><div class="ttdoc">Enable or disable a specific interrupt on the executing core.</div><div class="ttdef"><b>Definition:</b> irq.c:49</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The IO IRQs are independent per-processor. This method affects only the processor that calls the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">event_mask</td><td>Which events will cause an interrupt. See <a class="el" href="group__hardware__gpio.html#ga6347e27da3ab34f1ea65b5ae16ab724f">gpio_irq_level</a> for details. </td></tr>
    <tr><td class="paramname">enabled</td><td>Enable or disable flag </td></tr>
    <tr><td class="paramname">callback</td><td>user function to call on GPIO irq. if NULL, the callback is removed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9788ec1b8306c6bacfb578f0074eb3ad" name="ga9788ec1b8306c6bacfb578f0074eb3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9788ec1b8306c6bacfb578f0074eb3ad">&#9670;&nbsp;</a></span>gpio_set_irqover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_irqover </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GPIO IRQ override. </p>
<p >Optionally invert a GPIO IRQ signal, or drive it high or low</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">value</td><td>See <a class="el" href="gpio_8h.html#a760c408911eb8aaad767d39df9e4e990">gpio_override</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3aa12aa4543965e24f52cfa9b529904" name="gaf3aa12aa4543965e24f52cfa9b529904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3aa12aa4543965e24f52cfa9b529904">&#9670;&nbsp;</a></span>gpio_set_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_set_mask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drive high every GPIO appearing in mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO values to set, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga250e767769daabb71b5ea8cab49b4463" name="ga250e767769daabb71b5ea8cab49b4463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga250e767769daabb71b5ea8cab49b4463">&#9670;&nbsp;</a></span>gpio_set_oeover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_oeover </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select GPIO output enable override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">value</td><td>See <a class="el" href="gpio_8h.html#a760c408911eb8aaad767d39df9e4e990">gpio_override</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga829129eed5d42f3455e9da339219d814" name="ga829129eed5d42f3455e9da339219d814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga829129eed5d42f3455e9da339219d814">&#9670;&nbsp;</a></span>gpio_set_outover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_outover </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set GPIO output override. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">value</td><td>See <a class="el" href="gpio_8h.html#a760c408911eb8aaad767d39df9e4e990">gpio_override</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab6bf9552da32b3dd0a5d0db45d8374fc" name="gab6bf9552da32b3dd0a5d0db45d8374fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6bf9552da32b3dd0a5d0db45d8374fc">&#9670;&nbsp;</a></span>gpio_set_pulls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_pulls </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>down</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Select up and down pulls on specific GPIO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">up</td><td>If true set a pull up on the GPIO </td></tr>
    <tr><td class="paramname">down</td><td>If true set a pull down on the GPIO</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On the RP2040, setting both pulls enables a "bus keep" function, i.e. a weak pull to whatever is current high/low state of GPIO. </dd></dl>

</div>
</div>
<a id="gaf1d12efbed0809650d98fe9a424876c8" name="gaf1d12efbed0809650d98fe9a424876c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1d12efbed0809650d98fe9a424876c8">&#9670;&nbsp;</a></span>gpio_set_slew_rate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void gpio_set_slew_rate </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__hardware__gpio.html#ga72c250c9393043ea5beb56092d26e229">gpio_slew_rate</a>&#160;</td>
          <td class="paramname"><em>slew</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set slew rate for a specified GPIO. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__hardware__gpio.html#ga4422d9c09199d199e8fe736b3c29ae49" title="Determine current slew rate for a specified GPIO.">gpio_get_slew_rate</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO number </td></tr>
    <tr><td class="paramname">slew</td><td>GPIO output slew rate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga64de3fa94def1d5e8c87f419f25ea7fd" name="ga64de3fa94def1d5e8c87f419f25ea7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64de3fa94def1d5e8c87f419f25ea7fd">&#9670;&nbsp;</a></span>gpio_xor_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void gpio_xor_mask </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle every GPIO appearing in mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmask of GPIO values to toggle, as bits 0-29 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>