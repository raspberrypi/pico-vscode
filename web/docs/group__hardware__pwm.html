<!-- HTML header for doxygen 1.8.20-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.9.4"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>Raspberry Pi Pico SDK: hardware_pwm</title>
	<!-- <link href="tabs.css" rel="stylesheet" type="text/css"/> -->
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
	<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="normalise.css" rel="stylesheet" type="text/css"/>
<link href="main.css" rel="stylesheet" type="text/css"/>
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
	<div class="navigation-mobile">
		<div class="logo--mobile">
			<a href="/"><img src="logo-mobile.svg" alt="Raspberry Pi"></a>
		</div>
		<div class="navigation-toggle">
			<span class="line-1"></span>
			<span class="line-2">
				<p>Menu Toggle</p>
			</span>
			<span class="line-3"></span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
		<div class="logo">
			<a href="index.html"> <img src="logo.svg" alt="Raspberry Pi"></a>
			<span style="display: inline-block; margin-top: 10px;">
				v1.5.1
			</span>
		</div>
		<div class="navigation-footer">
			<img src="logo-mobile.svg" alt="Raspberry Pi">
			<a href="https://www.raspberrypi.com/" target="_blank">By Raspberry Pi Ltd</a>
		</div>
<!-- 		<div class="search">
			<form>
				<input type="search" name="search" id="search" placeholder="Search">
				<input type="submit" value="Search">
			</form>
		</div> -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('group__hardware__pwm.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">hardware_pwm<div class="ingroups"><a class="el" href="group__hardware.html">Hardware APIs</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0a00197703c8606641488cfff3f660e6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a> { <a class="el" href="group__hardware__pwm.html#gga0a00197703c8606641488cfff3f660e6acd3efbc3feaca58b87930008fdd8486b">PWM_DIV_FREE_RUNNING</a> = 0
, <a class="el" href="group__hardware__pwm.html#gga0a00197703c8606641488cfff3f660e6a186c27a4768fcb0c6930471db51861b7">PWM_DIV_B_HIGH</a> = 1
, <a class="el" href="group__hardware__pwm.html#gga0a00197703c8606641488cfff3f660e6ad9d2170532c2c9ab4016908544c8ad40">PWM_DIV_B_RISING</a> = 2
, <a class="el" href="group__hardware__pwm.html#gga0a00197703c8606641488cfff3f660e6a0b4afcaa75090169d3b7cbec4c0e2012">PWM_DIV_B_FALLING</a> = 3
 }</td></tr>
<tr class="memdesc:ga0a00197703c8606641488cfff3f660e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">PWM Divider mode settings.  <a href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">More...</a><br /></td></tr>
<tr class="separator:ga0a00197703c8606641488cfff3f660e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8b2117d67a544f64c001f4f32c723eef"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga8b2117d67a544f64c001f4f32c723eef">pwm_gpio_to_slice_num</a> (uint gpio)</td></tr>
<tr class="memdesc:ga8b2117d67a544f64c001f4f32c723eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the PWM slice that is attached to the specified GPIO.  <a href="group__hardware__pwm.html#ga8b2117d67a544f64c001f4f32c723eef">More...</a><br /></td></tr>
<tr class="separator:ga8b2117d67a544f64c001f4f32c723eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96ba504fe00cb8e0d88f0730cdfdaafc"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga96ba504fe00cb8e0d88f0730cdfdaafc">pwm_gpio_to_channel</a> (uint gpio)</td></tr>
<tr class="memdesc:ga96ba504fe00cb8e0d88f0730cdfdaafc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the PWM channel that is attached to the specified GPIO.  <a href="group__hardware__pwm.html#ga96ba504fe00cb8e0d88f0730cdfdaafc">More...</a><br /></td></tr>
<tr class="separator:ga96ba504fe00cb8e0d88f0730cdfdaafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga031fe8a502c9640ed4f5fab74d6248ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga031fe8a502c9640ed4f5fab74d6248ae">pwm_config_set_phase_correct</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, bool phase_correct)</td></tr>
<tr class="memdesc:ga031fe8a502c9640ed4f5fab74d6248ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set phase correction in a PWM configuration.  <a href="group__hardware__pwm.html#ga031fe8a502c9640ed4f5fab74d6248ae">More...</a><br /></td></tr>
<tr class="separator:ga031fe8a502c9640ed4f5fab74d6248ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga679802450ac829eff368e8f109df387e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga679802450ac829eff368e8f109df387e">pwm_config_set_clkdiv</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, float div)</td></tr>
<tr class="memdesc:ga679802450ac829eff368e8f109df387e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM clock divider in a PWM configuration.  <a href="group__hardware__pwm.html#ga679802450ac829eff368e8f109df387e">More...</a><br /></td></tr>
<tr class="separator:ga679802450ac829eff368e8f109df387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0d7a6e493b4dc9ded8f53fb9be474c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga3b0d7a6e493b4dc9ded8f53fb9be474c">pwm_config_set_clkdiv_int_frac</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, uint8_t integer, uint8_t fract)</td></tr>
<tr class="memdesc:ga3b0d7a6e493b4dc9ded8f53fb9be474c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM clock divider in a PWM configuration using an 8:4 fractional value.  <a href="group__hardware__pwm.html#ga3b0d7a6e493b4dc9ded8f53fb9be474c">More...</a><br /></td></tr>
<tr class="separator:ga3b0d7a6e493b4dc9ded8f53fb9be474c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d60d45df884a7abbde52e326586d55a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga1d60d45df884a7abbde52e326586d55a">pwm_config_set_clkdiv_int</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, uint div)</td></tr>
<tr class="memdesc:ga1d60d45df884a7abbde52e326586d55a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM clock divider in a PWM configuration.  <a href="group__hardware__pwm.html#ga1d60d45df884a7abbde52e326586d55a">More...</a><br /></td></tr>
<tr class="separator:ga1d60d45df884a7abbde52e326586d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a86a921b2ad2ebd811db1255d34d06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga27a86a921b2ad2ebd811db1255d34d06">pwm_config_set_clkdiv_mode</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, enum <a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a> mode)</td></tr>
<tr class="memdesc:ga27a86a921b2ad2ebd811db1255d34d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM counting mode in a PWM configuration.  <a href="group__hardware__pwm.html#ga27a86a921b2ad2ebd811db1255d34d06">More...</a><br /></td></tr>
<tr class="separator:ga27a86a921b2ad2ebd811db1255d34d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab459185e217d5e215dae3cfb3d6de1b5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gab459185e217d5e215dae3cfb3d6de1b5">pwm_config_set_output_polarity</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, bool a, bool b)</td></tr>
<tr class="memdesc:gab459185e217d5e215dae3cfb3d6de1b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set output polarity in a PWM configuration.  <a href="group__hardware__pwm.html#gab459185e217d5e215dae3cfb3d6de1b5">More...</a><br /></td></tr>
<tr class="separator:gab459185e217d5e215dae3cfb3d6de1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6cf6d9237144234732a50eb6d5e4fe9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gad6cf6d9237144234732a50eb6d5e4fe9">pwm_config_set_wrap</a> (<a class="el" href="structpwm__config.html">pwm_config</a> *c, uint16_t wrap)</td></tr>
<tr class="memdesc:gad6cf6d9237144234732a50eb6d5e4fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM counter wrap value in a PWM configuration.  <a href="group__hardware__pwm.html#gad6cf6d9237144234732a50eb6d5e4fe9">More...</a><br /></td></tr>
<tr class="separator:gad6cf6d9237144234732a50eb6d5e4fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d3e90bb7aa9a8b6884eddbfbebc175"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga01d3e90bb7aa9a8b6884eddbfbebc175">pwm_init</a> (uint slice_num, <a class="el" href="structpwm__config.html">pwm_config</a> *c, bool start)</td></tr>
<tr class="memdesc:ga01d3e90bb7aa9a8b6884eddbfbebc175"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a PWM with settings from a configuration object.  <a href="group__hardware__pwm.html#ga01d3e90bb7aa9a8b6884eddbfbebc175">More...</a><br /></td></tr>
<tr class="separator:ga01d3e90bb7aa9a8b6884eddbfbebc175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad76f94a6dd6133c52284b6be8ae98e16"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structpwm__config.html">pwm_config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gad76f94a6dd6133c52284b6be8ae98e16">pwm_get_default_config</a> (void)</td></tr>
<tr class="memdesc:gad76f94a6dd6133c52284b6be8ae98e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a set of default values for PWM configuration.  <a href="group__hardware__pwm.html#gad76f94a6dd6133c52284b6be8ae98e16">More...</a><br /></td></tr>
<tr class="separator:gad76f94a6dd6133c52284b6be8ae98e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f8fe346e6912cfab3d36b00043a3627"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga6f8fe346e6912cfab3d36b00043a3627">pwm_set_wrap</a> (uint slice_num, uint16_t wrap)</td></tr>
<tr class="memdesc:ga6f8fe346e6912cfab3d36b00043a3627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current PWM counter wrap value.  <a href="group__hardware__pwm.html#ga6f8fe346e6912cfab3d36b00043a3627">More...</a><br /></td></tr>
<tr class="separator:ga6f8fe346e6912cfab3d36b00043a3627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18a2b3bbc240d1a9b36526d69c06ec3d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga18a2b3bbc240d1a9b36526d69c06ec3d">pwm_set_chan_level</a> (uint slice_num, uint chan, uint16_t level)</td></tr>
<tr class="memdesc:ga18a2b3bbc240d1a9b36526d69c06ec3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current PWM counter compare value for one channel.  <a href="group__hardware__pwm.html#ga18a2b3bbc240d1a9b36526d69c06ec3d">More...</a><br /></td></tr>
<tr class="separator:ga18a2b3bbc240d1a9b36526d69c06ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7064c88717eee935e50138f5b0ae2b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gae7064c88717eee935e50138f5b0ae2b7">pwm_set_both_levels</a> (uint slice_num, uint16_t level_a, uint16_t level_b)</td></tr>
<tr class="memdesc:gae7064c88717eee935e50138f5b0ae2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM counter compare values.  <a href="group__hardware__pwm.html#gae7064c88717eee935e50138f5b0ae2b7">More...</a><br /></td></tr>
<tr class="separator:gae7064c88717eee935e50138f5b0ae2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279d1ba7dcc8f19619f389317efb41fd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga279d1ba7dcc8f19619f389317efb41fd">pwm_set_gpio_level</a> (uint gpio, uint16_t level)</td></tr>
<tr class="memdesc:ga279d1ba7dcc8f19619f389317efb41fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to set the PWM level for the slice and channel associated with a GPIO.  <a href="group__hardware__pwm.html#ga279d1ba7dcc8f19619f389317efb41fd">More...</a><br /></td></tr>
<tr class="separator:ga279d1ba7dcc8f19619f389317efb41fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga157c8b11483967714823187725a5ed5a"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga157c8b11483967714823187725a5ed5a">pwm_get_counter</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga157c8b11483967714823187725a5ed5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PWM counter.  <a href="group__hardware__pwm.html#ga157c8b11483967714823187725a5ed5a">More...</a><br /></td></tr>
<tr class="separator:ga157c8b11483967714823187725a5ed5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5179ec971146ab611b9232587e945769"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga5179ec971146ab611b9232587e945769">pwm_set_counter</a> (uint slice_num, uint16_t c)</td></tr>
<tr class="memdesc:ga5179ec971146ab611b9232587e945769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM counter.  <a href="group__hardware__pwm.html#ga5179ec971146ab611b9232587e945769">More...</a><br /></td></tr>
<tr class="separator:ga5179ec971146ab611b9232587e945769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98a47b25fcc2f28addf0a28ee3234efd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga98a47b25fcc2f28addf0a28ee3234efd">pwm_advance_count</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga98a47b25fcc2f28addf0a28ee3234efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance PWM count.  <a href="group__hardware__pwm.html#ga98a47b25fcc2f28addf0a28ee3234efd">More...</a><br /></td></tr>
<tr class="separator:ga98a47b25fcc2f28addf0a28ee3234efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dec65009d8c0738677818b680fd2ad9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga0dec65009d8c0738677818b680fd2ad9">pwm_retard_count</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga0dec65009d8c0738677818b680fd2ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retard PWM count.  <a href="group__hardware__pwm.html#ga0dec65009d8c0738677818b680fd2ad9">More...</a><br /></td></tr>
<tr class="separator:ga0dec65009d8c0738677818b680fd2ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0da8e86adb7de041a6b8607b36aee442"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga0da8e86adb7de041a6b8607b36aee442">pwm_set_clkdiv_int_frac</a> (uint slice_num, uint8_t integer, uint8_t fract)</td></tr>
<tr class="memdesc:ga0da8e86adb7de041a6b8607b36aee442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM clock divider using an 8:4 fractional value.  <a href="group__hardware__pwm.html#ga0da8e86adb7de041a6b8607b36aee442">More...</a><br /></td></tr>
<tr class="separator:ga0da8e86adb7de041a6b8607b36aee442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94782fc53adb07a3594ae0939d9a2e3e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga94782fc53adb07a3594ae0939d9a2e3e">pwm_set_clkdiv</a> (uint slice_num, float divider)</td></tr>
<tr class="memdesc:ga94782fc53adb07a3594ae0939d9a2e3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM clock divider.  <a href="group__hardware__pwm.html#ga94782fc53adb07a3594ae0939d9a2e3e">More...</a><br /></td></tr>
<tr class="separator:ga94782fc53adb07a3594ae0939d9a2e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12ab09d76aed43a36f973232718fdd6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gab12ab09d76aed43a36f973232718fdd6">pwm_set_output_polarity</a> (uint slice_num, bool a, bool b)</td></tr>
<tr class="memdesc:gab12ab09d76aed43a36f973232718fdd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM output polarity.  <a href="group__hardware__pwm.html#gab12ab09d76aed43a36f973232718fdd6">More...</a><br /></td></tr>
<tr class="separator:gab12ab09d76aed43a36f973232718fdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee213ebb13b98dc81e60a512f696227"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga1ee213ebb13b98dc81e60a512f696227">pwm_set_clkdiv_mode</a> (uint slice_num, enum <a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a> mode)</td></tr>
<tr class="memdesc:ga1ee213ebb13b98dc81e60a512f696227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM divider mode.  <a href="group__hardware__pwm.html#ga1ee213ebb13b98dc81e60a512f696227">More...</a><br /></td></tr>
<tr class="separator:ga1ee213ebb13b98dc81e60a512f696227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb2a1995f0bfdb12345607b903c3f11e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gacb2a1995f0bfdb12345607b903c3f11e">pwm_set_phase_correct</a> (uint slice_num, bool phase_correct)</td></tr>
<tr class="memdesc:gacb2a1995f0bfdb12345607b903c3f11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set PWM phase correct on/off.  <a href="group__hardware__pwm.html#gacb2a1995f0bfdb12345607b903c3f11e">More...</a><br /></td></tr>
<tr class="separator:gacb2a1995f0bfdb12345607b903c3f11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga216496c331542eb57199018fa86b4408"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga216496c331542eb57199018fa86b4408">pwm_set_enabled</a> (uint slice_num, bool enabled)</td></tr>
<tr class="memdesc:ga216496c331542eb57199018fa86b4408"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable PWM.  <a href="group__hardware__pwm.html#ga216496c331542eb57199018fa86b4408">More...</a><br /></td></tr>
<tr class="separator:ga216496c331542eb57199018fa86b4408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257ea7fd33fcf33815a01dd279ca578d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga257ea7fd33fcf33815a01dd279ca578d">pwm_set_mask_enabled</a> (uint32_t mask)</td></tr>
<tr class="memdesc:ga257ea7fd33fcf33815a01dd279ca578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/Disable multiple PWM slices simultaneously.  <a href="group__hardware__pwm.html#ga257ea7fd33fcf33815a01dd279ca578d">More...</a><br /></td></tr>
<tr class="separator:ga257ea7fd33fcf33815a01dd279ca578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga093a3c371dda3aa2291331147337265e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga093a3c371dda3aa2291331147337265e">pwm_set_irq_enabled</a> (uint slice_num, bool enabled)</td></tr>
<tr class="memdesc:ga093a3c371dda3aa2291331147337265e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable PWM instance interrupt.  <a href="group__hardware__pwm.html#ga093a3c371dda3aa2291331147337265e">More...</a><br /></td></tr>
<tr class="separator:ga093a3c371dda3aa2291331147337265e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32a9b468ddbd49bad6ebff6789fd215"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#gac32a9b468ddbd49bad6ebff6789fd215">pwm_set_irq_mask_enabled</a> (uint32_t slice_mask, bool enabled)</td></tr>
<tr class="memdesc:gac32a9b468ddbd49bad6ebff6789fd215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable multiple PWM instance interrupts.  <a href="group__hardware__pwm.html#gac32a9b468ddbd49bad6ebff6789fd215">More...</a><br /></td></tr>
<tr class="separator:gac32a9b468ddbd49bad6ebff6789fd215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d4482b5e125e30bc166d3ed33d8ba2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga8d4482b5e125e30bc166d3ed33d8ba2d">pwm_clear_irq</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga8d4482b5e125e30bc166d3ed33d8ba2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a single PWM channel interrupt.  <a href="group__hardware__pwm.html#ga8d4482b5e125e30bc166d3ed33d8ba2d">More...</a><br /></td></tr>
<tr class="separator:ga8d4482b5e125e30bc166d3ed33d8ba2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga565a6b6d19b60b10f5a91b11152cc8c2"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga565a6b6d19b60b10f5a91b11152cc8c2">pwm_get_irq_status_mask</a> (void)</td></tr>
<tr class="memdesc:ga565a6b6d19b60b10f5a91b11152cc8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get PWM interrupt status, raw.  <a href="group__hardware__pwm.html#ga565a6b6d19b60b10f5a91b11152cc8c2">More...</a><br /></td></tr>
<tr class="separator:ga565a6b6d19b60b10f5a91b11152cc8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga457ee599e471a8da59c42f5c26710ff6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga457ee599e471a8da59c42f5c26710ff6">pwm_force_irq</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga457ee599e471a8da59c42f5c26710ff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Force PWM interrupt.  <a href="group__hardware__pwm.html#ga457ee599e471a8da59c42f5c26710ff6">More...</a><br /></td></tr>
<tr class="separator:ga457ee599e471a8da59c42f5c26710ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f600a7192ecd69a8680be367e8d0a00"><td class="memItemLeft" align="right" valign="top">static uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__hardware__pwm.html#ga2f600a7192ecd69a8680be367e8d0a00">pwm_get_dreq</a> (uint slice_num)</td></tr>
<tr class="memdesc:ga2f600a7192ecd69a8680be367e8d0a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the DREQ to use for pacing transfers to a particular PWM slice.  <a href="group__hardware__pwm.html#ga2f600a7192ecd69a8680be367e8d0a00">More...</a><br /></td></tr>
<tr class="separator:ga2f600a7192ecd69a8680be367e8d0a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p >Hardware Pulse Width Modulation (PWM) API</p>
<p >The RP2040 PWM block has 8 identical slices. Each slice can drive two PWM output signals, or measure the frequency or duty cycle of an input signal. This gives a total of up to 16 controllable PWM outputs. All 30 GPIOs can be driven by the PWM block.</p>
<p >The PWM hardware functions by continuously comparing the input value to a free-running counter. This produces a toggling output where the amount of time spent at the high output level is proportional to the input value. The fraction of time spent at the high signal level is known as the duty cycle of the signal.</p>
<p >The default behaviour of a PWM slice is to count upward until the wrap value (<a class="el" href="group__hardware__pwm.html#gad6cf6d9237144234732a50eb6d5e4fe9">pwm_config_set_wrap</a>) is reached, and then immediately wrap to 0. PWM slices also offer a phase-correct mode, where the counter starts to count downward after reaching TOP, until it reaches 0 again.</p>
<h2><a class="anchor" id="pwm_example"></a>
Example</h2>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="comment">// Output PWM signals on pins 0 and 1</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="stdlib_8h.html">pico/stdlib.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="rp2__common_2hardware__pwm_2include_2hardware_2pwm_8h.html">hardware/pwm.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Tell GPIO 0 and 1 they are allocated to the PWM</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">gpio_set_function</a>(0, GPIO_FUNC_PWM);</div>
<div class="line">    <a class="code hl_function" href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">gpio_set_function</a>(1, GPIO_FUNC_PWM);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Find out which PWM slice is connected to GPIO 0 (it&#39;s slice 0)</span></div>
<div class="line">    uint slice_num = <a class="code hl_function" href="group__hardware__pwm.html#ga8b2117d67a544f64c001f4f32c723eef">pwm_gpio_to_slice_num</a>(0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set period of 4 cycles (0 to 3 inclusive)</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__pwm.html#ga6f8fe346e6912cfab3d36b00043a3627">pwm_set_wrap</a>(slice_num, 3);</div>
<div class="line">    <span class="comment">// Set channel A output high for one cycle before dropping</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__pwm.html#ga18a2b3bbc240d1a9b36526d69c06ec3d">pwm_set_chan_level</a>(slice_num, PWM_CHAN_A, 1);</div>
<div class="line">    <span class="comment">// Set initial B output high for three cycles before dropping</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__pwm.html#ga18a2b3bbc240d1a9b36526d69c06ec3d">pwm_set_chan_level</a>(slice_num, PWM_CHAN_B, 3);</div>
<div class="line">    <span class="comment">// Set the PWM running</span></div>
<div class="line">    <a class="code hl_function" href="group__hardware__pwm.html#ga216496c331542eb57199018fa86b4408">pwm_set_enabled</a>(slice_num, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Note we could also use pwm_set_gpio_level(gpio, x) which looks up the</span></div>
<div class="line">    <span class="comment">// correct slice and channel for a given GPIO.</span></div>
<div class="line">}</div>
<div class="ttc" id="agroup__hardware__gpio_html_gaacde9174277ca40aa7b6fdd341bb2b8c"><div class="ttname"><a href="group__hardware__gpio.html#gaacde9174277ca40aa7b6fdd341bb2b8c">gpio_set_function</a></div><div class="ttdeci">void gpio_set_function(uint gpio, enum gpio_function fn)</div><div class="ttdoc">Select GPIO function.</div><div class="ttdef"><b>Definition:</b> gpio.c:32</div></div>
<div class="ttc" id="agroup__hardware__pwm_html_ga18a2b3bbc240d1a9b36526d69c06ec3d"><div class="ttname"><a href="group__hardware__pwm.html#ga18a2b3bbc240d1a9b36526d69c06ec3d">pwm_set_chan_level</a></div><div class="ttdeci">static void pwm_set_chan_level(uint slice_num, uint chan, uint16_t level)</div><div class="ttdoc">Set the current PWM counter compare value for one channel.</div><div class="ttdef"><b>Definition:</b> pwm.h:274</div></div>
<div class="ttc" id="agroup__hardware__pwm_html_ga216496c331542eb57199018fa86b4408"><div class="ttname"><a href="group__hardware__pwm.html#ga216496c331542eb57199018fa86b4408">pwm_set_enabled</a></div><div class="ttdeci">static void pwm_set_enabled(uint slice_num, bool enabled)</div><div class="ttdoc">Enable/Disable PWM.</div><div class="ttdef"><b>Definition:</b> pwm.h:488</div></div>
<div class="ttc" id="agroup__hardware__pwm_html_ga6f8fe346e6912cfab3d36b00043a3627"><div class="ttname"><a href="group__hardware__pwm.html#ga6f8fe346e6912cfab3d36b00043a3627">pwm_set_wrap</a></div><div class="ttdeci">static void pwm_set_wrap(uint slice_num, uint16_t wrap)</div><div class="ttdoc">Set the current PWM counter wrap value.</div><div class="ttdef"><b>Definition:</b> pwm.h:254</div></div>
<div class="ttc" id="agroup__hardware__pwm_html_ga8b2117d67a544f64c001f4f32c723eef"><div class="ttname"><a href="group__hardware__pwm.html#ga8b2117d67a544f64c001f4f32c723eef">pwm_gpio_to_slice_num</a></div><div class="ttdeci">static uint pwm_gpio_to_slice_num(uint gpio)</div><div class="ttdoc">Determine the PWM slice that is attached to the specified GPIO.</div><div class="ttdef"><b>Definition:</b> pwm.h:78</div></div>
<div class="ttc" id="arp2__common_2hardware__pwm_2include_2hardware_2pwm_8h_html"><div class="ttname"><a href="rp2__common_2hardware__pwm_2include_2hardware_2pwm_8h.html">pwm.h</a></div></div>
<div class="ttc" id="astdlib_8h_html"><div class="ttname"><a href="stdlib_8h.html">stdlib.h</a></div></div>
</div><!-- fragment --> <h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga0a00197703c8606641488cfff3f660e6" name="ga0a00197703c8606641488cfff3f660e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a00197703c8606641488cfff3f660e6">&#9670;&nbsp;</a></span>pwm_clkdiv_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>PWM Divider mode settings. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga0a00197703c8606641488cfff3f660e6acd3efbc3feaca58b87930008fdd8486b" name="gga0a00197703c8606641488cfff3f660e6acd3efbc3feaca58b87930008fdd8486b"></a>PWM_DIV_FREE_RUNNING&#160;</td><td class="fielddoc"><p >Free-running counting at rate dictated by fractional divider. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a00197703c8606641488cfff3f660e6a186c27a4768fcb0c6930471db51861b7" name="gga0a00197703c8606641488cfff3f660e6a186c27a4768fcb0c6930471db51861b7"></a>PWM_DIV_B_HIGH&#160;</td><td class="fielddoc"><p >Fractional divider is gated by the PWM B pin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a00197703c8606641488cfff3f660e6ad9d2170532c2c9ab4016908544c8ad40" name="gga0a00197703c8606641488cfff3f660e6ad9d2170532c2c9ab4016908544c8ad40"></a>PWM_DIV_B_RISING&#160;</td><td class="fielddoc"><p >Fractional divider advances with each rising edge of the PWM B pin. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga0a00197703c8606641488cfff3f660e6a0b4afcaa75090169d3b7cbec4c0e2012" name="gga0a00197703c8606641488cfff3f660e6a0b4afcaa75090169d3b7cbec4c0e2012"></a>PWM_DIV_B_FALLING&#160;</td><td class="fielddoc"><p >Fractional divider advances with each falling edge of the PWM B pin. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga98a47b25fcc2f28addf0a28ee3234efd" name="ga98a47b25fcc2f28addf0a28ee3234efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98a47b25fcc2f28addf0a28ee3234efd">&#9670;&nbsp;</a></span>pwm_advance_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_advance_count </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advance PWM count. </p>
<p >Advance the phase of a running the counter by 1 count.</p>
<p >This function will return once the increment is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8d4482b5e125e30bc166d3ed33d8ba2d" name="ga8d4482b5e125e30bc166d3ed33d8ba2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d4482b5e125e30bc166d3ed33d8ba2d">&#9670;&nbsp;</a></span>pwm_clear_irq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_clear_irq </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear a single PWM channel interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga679802450ac829eff368e8f109df387e" name="ga679802450ac829eff368e8f109df387e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga679802450ac829eff368e8f109df387e">&#9670;&nbsp;</a></span>pwm_config_set_clkdiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_clkdiv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM clock divider in a PWM configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">div</td><td>Value to divide counting rate by. Must be greater than or equal to 1.</td></tr>
  </table>
  </dd>
</dl>
<p>If the divide mode is free-running, the PWM counter runs at clk_sys / div. Otherwise, the divider reduces the rate of events seen on the B pin input (level or edge) before passing them on to the PWM counter. </p>

</div>
</div>
<a id="ga1d60d45df884a7abbde52e326586d55a" name="ga1d60d45df884a7abbde52e326586d55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d60d45df884a7abbde52e326586d55a">&#9670;&nbsp;</a></span>pwm_config_set_clkdiv_int()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_clkdiv_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>div</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM clock divider in a PWM configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">div</td><td>Integer value to reduce counting rate by. Must be greater than or equal to 1.</td></tr>
  </table>
  </dd>
</dl>
<p>If the divide mode is free-running, the PWM counter runs at clk_sys / div. Otherwise, the divider reduces the rate of events seen on the B pin input (level or edge) before passing them on to the PWM counter. </p>

</div>
</div>
<a id="ga3b0d7a6e493b4dc9ded8f53fb9be474c" name="ga3b0d7a6e493b4dc9ded8f53fb9be474c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b0d7a6e493b4dc9ded8f53fb9be474c">&#9670;&nbsp;</a></span>pwm_config_set_clkdiv_int_frac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_clkdiv_int_frac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>fract</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM clock divider in a PWM configuration using an 8:4 fractional value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">integer</td><td>8 bit integer part of the clock divider. Must be greater than or equal to 1. </td></tr>
    <tr><td class="paramname">fract</td><td>4 bit fractional part of the clock divider</td></tr>
  </table>
  </dd>
</dl>
<p>If the divide mode is free-running, the PWM counter runs at clk_sys / div. Otherwise, the divider reduces the rate of events seen on the B pin input (level or edge) before passing them on to the PWM counter. </p>

</div>
</div>
<a id="ga27a86a921b2ad2ebd811db1255d34d06" name="ga27a86a921b2ad2ebd811db1255d34d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a86a921b2ad2ebd811db1255d34d06">&#9670;&nbsp;</a></span>pwm_config_set_clkdiv_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_clkdiv_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM counting mode in a PWM configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">mode</td><td>PWM divide/count mode</td></tr>
  </table>
  </dd>
</dl>
<p>Configure which event gates the operation of the fractional divider. The default is always-on (free-running PWM). Can also be configured to count on high level, rising edge or falling edge of the B pin input. </p>

</div>
</div>
<a id="gab459185e217d5e215dae3cfb3d6de1b5" name="gab459185e217d5e215dae3cfb3d6de1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab459185e217d5e215dae3cfb3d6de1b5">&#9670;&nbsp;</a></span>pwm_config_set_output_polarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_output_polarity </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set output polarity in a PWM configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">a</td><td>true to invert output A </td></tr>
    <tr><td class="paramname">b</td><td>true to invert output B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga031fe8a502c9640ed4f5fab74d6248ae" name="ga031fe8a502c9640ed4f5fab74d6248ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga031fe8a502c9640ed4f5fab74d6248ae">&#9670;&nbsp;</a></span>pwm_config_set_phase_correct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_phase_correct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>phase_correct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set phase correction in a PWM configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">phase_correct</td><td>true to set phase correct modulation, false to set trailing edge</td></tr>
  </table>
  </dd>
</dl>
<p>Setting phase control to true means that instead of wrapping back to zero when the wrap point is reached, the PWM starts counting back down. The output frequency is halved when phase-correct mode is enabled. </p>

</div>
</div>
<a id="gad6cf6d9237144234732a50eb6d5e4fe9" name="gad6cf6d9237144234732a50eb6d5e4fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6cf6d9237144234732a50eb6d5e4fe9">&#9670;&nbsp;</a></span>pwm_config_set_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_config_set_wrap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM counter wrap value in a PWM configuration. </p>
<p >Set the highest value the counter will reach before returning to 0. Also known as TOP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>PWM configuration struct to modify </td></tr>
    <tr><td class="paramname">wrap</td><td>Value to set wrap to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga457ee599e471a8da59c42f5c26710ff6" name="ga457ee599e471a8da59c42f5c26710ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga457ee599e471a8da59c42f5c26710ff6">&#9670;&nbsp;</a></span>pwm_force_irq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_force_irq </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Force PWM interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga157c8b11483967714823187725a5ed5a" name="ga157c8b11483967714823187725a5ed5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga157c8b11483967714823187725a5ed5a">&#9670;&nbsp;</a></span>pwm_get_counter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t pwm_get_counter </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PWM counter. </p>
<p >Get current value of PWM counter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Current value of the PWM counter </dd></dl>

</div>
</div>
<a id="gad76f94a6dd6133c52284b6be8ae98e16" name="gad76f94a6dd6133c52284b6be8ae98e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad76f94a6dd6133c52284b6be8ae98e16">&#9670;&nbsp;</a></span>pwm_get_default_config()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structpwm__config.html">pwm_config</a> pwm_get_default_config </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a set of default values for PWM configuration. </p>
<p >PWM config is free-running at system clock speed, no phase correction, wrapping at 0xffff, with standard polarities for channels A and B.</p>
<dl class="section return"><dt>Returns</dt><dd>Set of default values. </dd></dl>

</div>
</div>
<a id="ga2f600a7192ecd69a8680be367e8d0a00" name="ga2f600a7192ecd69a8680be367e8d0a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f600a7192ecd69a8680be367e8d0a00">&#9670;&nbsp;</a></span>pwm_get_dreq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint pwm_get_dreq </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the DREQ to use for pacing transfers to a particular PWM slice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga565a6b6d19b60b10f5a91b11152cc8c2" name="ga565a6b6d19b60b10f5a91b11152cc8c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga565a6b6d19b60b10f5a91b11152cc8c2">&#9670;&nbsp;</a></span>pwm_get_irq_status_mask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t pwm_get_irq_status_mask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get PWM interrupt status, raw. </p>
<dl class="section return"><dt>Returns</dt><dd>Bitmask of all PWM interrupts currently set </dd></dl>

</div>
</div>
<a id="ga96ba504fe00cb8e0d88f0730cdfdaafc" name="ga96ba504fe00cb8e0d88f0730cdfdaafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96ba504fe00cb8e0d88f0730cdfdaafc">&#9670;&nbsp;</a></span>pwm_gpio_to_channel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint pwm_gpio_to_channel </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the PWM channel that is attached to the specified GPIO. </p>
<p >Each slice 0 to 7 has two channels, A and B.</p>
<dl class="section return"><dt>Returns</dt><dd>The PWM channel that controls the specified GPIO. </dd></dl>

</div>
</div>
<a id="ga8b2117d67a544f64c001f4f32c723eef" name="ga8b2117d67a544f64c001f4f32c723eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2117d67a544f64c001f4f32c723eef">&#9670;&nbsp;</a></span>pwm_gpio_to_slice_num()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint pwm_gpio_to_slice_num </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the PWM slice that is attached to the specified GPIO. </p>
<dl class="section return"><dt>Returns</dt><dd>The PWM slice number that controls the specified GPIO. </dd></dl>

</div>
</div>
<a id="ga01d3e90bb7aa9a8b6884eddbfbebc175" name="ga01d3e90bb7aa9a8b6884eddbfbebc175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01d3e90bb7aa9a8b6884eddbfbebc175">&#9670;&nbsp;</a></span>pwm_init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_init </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpwm__config.html">pwm_config</a> *&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialise a PWM with settings from a configuration object. </p>
<p >Use the <a class="el" href="group__hardware__pwm.html#gad76f94a6dd6133c52284b6be8ae98e16">pwm_get_default_config()</a> function to initialise a config structure, make changes as needed using the pwm_config_* functions, then call this function to set up the PWM.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">c</td><td>The configuration to use </td></tr>
    <tr><td class="paramname">start</td><td>If true the PWM will be started running once configured. If false you will need to start manually using <a class="el" href="group__hardware__pwm.html#ga216496c331542eb57199018fa86b4408">pwm_set_enabled()</a> or <a class="el" href="group__hardware__pwm.html#ga257ea7fd33fcf33815a01dd279ca578d">pwm_set_mask_enabled()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0dec65009d8c0738677818b680fd2ad9" name="ga0dec65009d8c0738677818b680fd2ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dec65009d8c0738677818b680fd2ad9">&#9670;&nbsp;</a></span>pwm_retard_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_retard_count </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retard PWM count. </p>
<p >Retard the phase of a running counter by 1 count</p>
<p >This function will return once the retardation is complete.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7064c88717eee935e50138f5b0ae2b7" name="gae7064c88717eee935e50138f5b0ae2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7064c88717eee935e50138f5b0ae2b7">&#9670;&nbsp;</a></span>pwm_set_both_levels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_both_levels </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>level_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>level_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM counter compare values. </p>
<p >Set the value of the PWM counter compare values, A and B.</p>
<p >The counter compare register is double-buffered in hardware. This means that, when the PWM is running, a write to the counter compare values does not take effect until the next time the PWM slice wraps (or, in phase-correct mode, the next time the slice reaches 0). If the PWM is not running, the write is latched in immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">level_a</td><td>Value to set compare A to. When the counter reaches this value the A output is deasserted </td></tr>
    <tr><td class="paramname">level_b</td><td>Value to set compare B to. When the counter reaches this value the B output is deasserted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18a2b3bbc240d1a9b36526d69c06ec3d" name="ga18a2b3bbc240d1a9b36526d69c06ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18a2b3bbc240d1a9b36526d69c06ec3d">&#9670;&nbsp;</a></span>pwm_set_chan_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_chan_level </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>chan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current PWM counter compare value for one channel. </p>
<p >Set the value of the PWM counter compare value, for either channel A or channel B.</p>
<p >The counter compare register is double-buffered in hardware. This means that, when the PWM is running, a write to the counter compare values does not take effect until the next time the PWM slice wraps (or, in phase-correct mode, the next time the slice reaches 0). If the PWM is not running, the write is latched in immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">chan</td><td>Which channel to update. 0 for A, 1 for B. </td></tr>
    <tr><td class="paramname">level</td><td>new level for the selected output </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga94782fc53adb07a3594ae0939d9a2e3e" name="ga94782fc53adb07a3594ae0939d9a2e3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94782fc53adb07a3594ae0939d9a2e3e">&#9670;&nbsp;</a></span>pwm_set_clkdiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_clkdiv </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>divider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM clock divider. </p>
<p >Set the clock divider. Counter increment will be on sysclock divided by this value, taking into account the gating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">divider</td><td>Floating point clock divider, 1.f &lt;= value &lt; 256.f </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0da8e86adb7de041a6b8607b36aee442" name="ga0da8e86adb7de041a6b8607b36aee442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0da8e86adb7de041a6b8607b36aee442">&#9670;&nbsp;</a></span>pwm_set_clkdiv_int_frac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_clkdiv_int_frac </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>fract</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM clock divider using an 8:4 fractional value. </p>
<p >Set the clock divider. Counter increment will be on sysclock divided by this value, taking into account the gating.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">integer</td><td>8 bit integer part of the clock divider </td></tr>
    <tr><td class="paramname">fract</td><td>4 bit fractional part of the clock divider </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1ee213ebb13b98dc81e60a512f696227" name="ga1ee213ebb13b98dc81e60a512f696227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ee213ebb13b98dc81e60a512f696227">&#9670;&nbsp;</a></span>pwm_set_clkdiv_mode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_clkdiv_mode </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__hardware__pwm.html#ga0a00197703c8606641488cfff3f660e6">pwm_clkdiv_mode</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM divider mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">mode</td><td>Required divider mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5179ec971146ab611b9232587e945769" name="ga5179ec971146ab611b9232587e945769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5179ec971146ab611b9232587e945769">&#9670;&nbsp;</a></span>pwm_set_counter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_counter </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM counter. </p>
<p >Set the value of the PWM counter</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">c</td><td>Value to set the PWM counter to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga216496c331542eb57199018fa86b4408" name="ga216496c331542eb57199018fa86b4408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga216496c331542eb57199018fa86b4408">&#9670;&nbsp;</a></span>pwm_set_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/Disable PWM. </p>
<p >When a PWM is disabled, it halts its counter, and the output pins are left high or low depending on exactly when the counter is halted. When re-enabled the PWM resumes immediately from where it left off.</p>
<p >If the PWM's output pins need to be low when halted:</p>
<ul>
<li>The counter compare can be set to zero whilst the PWM is enabled, and then the PWM disabled once both pins are seen to be low</li>
<li>The GPIO output overrides can be used to force the actual pins low</li>
<li>The PWM can be run for one cycle (i.e. enabled then immediately disabled) with a TOP of 0, count of 0 and counter compare of 0, to force the pins low when the PWM has already been halted. The same method can be used with a counter compare value of 1 to force a pin high.</li>
</ul>
<p >Note that, when disabled, the PWM can still be advanced one count at a time by pulsing the PH_ADV bit in its CSR. The output pins transition as though the PWM were enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable the specified PWM, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga279d1ba7dcc8f19619f389317efb41fd" name="ga279d1ba7dcc8f19619f389317efb41fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga279d1ba7dcc8f19619f389317efb41fd">&#9670;&nbsp;</a></span>pwm_set_gpio_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_gpio_level </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>gpio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to set the PWM level for the slice and channel associated with a GPIO. </p>
<p >Look up the correct slice (0 to 7) and channel (A or B) for a given GPIO, and update the corresponding counter compare field.</p>
<p >This PWM slice should already have been configured and set running. Also be careful of multiple GPIOs mapping to the same slice and channel (if GPIOs have a difference of 16).</p>
<p >The counter compare register is double-buffered in hardware. This means that, when the PWM is running, a write to the counter compare values does not take effect until the next time the PWM slice wraps (or, in phase-correct mode, the next time the slice reaches 0). If the PWM is not running, the write is latched in immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gpio</td><td>GPIO to set level of </td></tr>
    <tr><td class="paramname">level</td><td>PWM level for this GPIO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga093a3c371dda3aa2291331147337265e" name="ga093a3c371dda3aa2291331147337265e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga093a3c371dda3aa2291331147337265e">&#9670;&nbsp;</a></span>pwm_set_irq_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_irq_enabled </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable PWM instance interrupt. </p>
<p >Used to enable a single PWM instance interrupt.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM block to enable/disable </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable, false to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac32a9b468ddbd49bad6ebff6789fd215" name="gac32a9b468ddbd49bad6ebff6789fd215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32a9b468ddbd49bad6ebff6789fd215">&#9670;&nbsp;</a></span>pwm_set_irq_mask_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_irq_mask_enabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>slice_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable multiple PWM instance interrupts. </p>
<p >Use this to enable multiple PWM interrupts at once.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_mask</td><td>Bitmask of all the blocks to enable/disable. Channel 0 = bit 0, channel 1 = bit 1 etc. </td></tr>
    <tr><td class="paramname">enabled</td><td>true to enable, false to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga257ea7fd33fcf33815a01dd279ca578d" name="ga257ea7fd33fcf33815a01dd279ca578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga257ea7fd33fcf33815a01dd279ca578d">&#9670;&nbsp;</a></span>pwm_set_mask_enabled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_mask_enabled </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enable/Disable multiple PWM slices simultaneously. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Bitmap of PWMs to enable/disable. Bits 0 to 7 enable slices 0-7 respectively </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab12ab09d76aed43a36f973232718fdd6" name="gab12ab09d76aed43a36f973232718fdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab12ab09d76aed43a36f973232718fdd6">&#9670;&nbsp;</a></span>pwm_set_output_polarity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_output_polarity </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM output polarity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">a</td><td>true to invert output A </td></tr>
    <tr><td class="paramname">b</td><td>true to invert output B </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacb2a1995f0bfdb12345607b903c3f11e" name="gacb2a1995f0bfdb12345607b903c3f11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb2a1995f0bfdb12345607b903c3f11e">&#9670;&nbsp;</a></span>pwm_set_phase_correct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_phase_correct </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>phase_correct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set PWM phase correct on/off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">phase_correct</td><td>true to set phase correct modulation, false to set trailing edge</td></tr>
  </table>
  </dd>
</dl>
<p>Setting phase control to true means that instead of wrapping back to zero when the wrap point is reached, the PWM starts counting back down. The output frequency is halved when phase-correct mode is enabled. </p>

</div>
</div>
<a id="ga6f8fe346e6912cfab3d36b00043a3627" name="ga6f8fe346e6912cfab3d36b00043a3627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f8fe346e6912cfab3d36b00043a3627">&#9670;&nbsp;</a></span>pwm_set_wrap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void pwm_set_wrap </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>slice_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>wrap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the current PWM counter wrap value. </p>
<p >Set the highest value the counter will reach before returning to 0. Also known as TOP.</p>
<p >The counter wrap value is double-buffered in hardware. This means that, when the PWM is running, a write to the counter wrap value does not take effect until after the next time the PWM slice wraps (or, in phase-correct mode, the next time the slice reaches 0). If the PWM is not running, the write is latched in immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slice_num</td><td>PWM slice number </td></tr>
    <tr><td class="paramname">wrap</td><td>Value to set wrap to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

	<script src="main.js"></script>
</body>
</html>